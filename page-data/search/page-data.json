{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"gRPC 필수 도구 설치 가이드 1. Protocol Buffers 컴파일러 (protoc) 설치 파일 다운로드 프로토콜 버퍼 릴리즈 페이지 운영체제에 맞는 버전 선택 Windows:  Linux:  macOS:  운영체제별 설치 방법 Windows zip 파일 다운로드 및 압축 해제  디렉토리를 시스템 환경 변수 PATH에 추가 macOS Linux 설…","fields":{"slug":"/grpc-essential-tools/"},"frontmatter":{"date":"December 13, 2024","title":"gRPC 필수 도구 설치 가이드","tags":["gRPC","Protocol Buffers"]},"rawMarkdownBody":"\n# gRPC 필수 도구 설치 가이드\n\n## 1. Protocol Buffers 컴파일러 (protoc)\n\n### 설치 파일 다운로드\n\n- [프로토콜 버퍼 릴리즈 페이지](https://github.com/protocolbuffers/protobuf/releases)\n- 운영체제에 맞는 버전 선택\n  - Windows: `protoc-{version}-win64.zip`\n  - Linux: `protoc-{version}-linux-x86_64.zip`\n  - macOS: `protoc-{version}-osx-x86_64.zip`\n\n### 운영체제별 설치 방법\n\n#### Windows\n\n1. zip 파일 다운로드 및 압축 해제\n2. `bin` 디렉토리를 시스템 환경 변수 PATH에 추가\n\n```batch\nsetx PATH \"%PATH%;C:\\path\\to\\protoc\\bin\"\n```\n\n#### macOS\n\n```bash\n# Homebrew 사용\nbrew install protobuf\n\n# 또는 수동 설치\n# 1. zip 파일 다운로드\n# 2. 압축 해제\n# 3. PATH 설정\necho 'export PATH=$PATH:/path/to/protoc/bin' >> ~/.zshrc\nsource ~/.zshrc\n```\n\n#### Linux\n\n```bash\n# apt 사용\nsudo apt-get update\nsudo apt-get install protobuf-compiler\n\n# 또는 수동 설치\n# 1. zip 파일 다운로드\n# 2. 압축 해제\n# 3. PATH 설정\necho 'export PATH=$PATH:/path/to/protoc/bin' >> ~/.bashrc\nsource ~/.bashrc\n```\n\n### 설치 확인\n\n```bash\nprotoc --version\n# libprotoc x.x.x (버전 정보 출력)\n```\n\n## 2. Go Protocol Buffers 플러그인 (protoc-gen-go)\n\n### 설치 방법\n\n```bash\n# 최신 버전 설치\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 특정 버전 설치 (예: v1.28)\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28\n```\n\n### 설치 확인\n\n```bash\nwhich protoc-gen-go\n# Go bin 경로 출력 (예: /home/user/go/bin/protoc-gen-go)\n```\n\n## 3. Go gRPC 플러그인 (protoc-gen-go-grpc)\n\n### 설치 방법\n\n```bash\n# 최신 버전 설치\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\n# 특정 버전 설치\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2\n```\n\n### 설치 확인\n\n```bash\nwhich protoc-gen-go-grpc\n# Go bin 경로 출력\n```\n\n## PATH 설정 확인\n\n### Go bin 디렉토리 PATH 추가\n\n#### Windows\n\n```batch\nsetx PATH \"%PATH%;%GOPATH%\\bin\"\n```\n\n#### Linux/macOS\n\n```bash\n# ~/.bashrc 또는 ~/.zshrc에 추가\nexport PATH=$PATH:$(go env GOPATH)/bin\n```\n\n### 설정 확인\n\n```bash\n# 모든 필수 도구 설치 확인\nprotoc --version\nwhich protoc-gen-go\nwhich protoc-gen-go-grpc\n```\n\n## 프로토 파일 컴파일 테스트\n\n### 테스트 프로토 파일 생성\n\n```protobuf\n// test.proto\nsyntax = \"proto3\";\n\npackage test;\n\noption go_package = \"example/test\";\n\nmessage Test {\n  string name = 1;\n}\n```\n\n### 컴파일 테스트\n\n```bash\nprotoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    test.proto\n```\n\n## 트러블슈팅\n\n### 일반적인 문제 해결\n\n1. `protoc-gen-go: program not found`\n\n```bash\n# Go bin 디렉토리가 PATH에 있는지 확인\necho $PATH | grep \"go/bin\"\n\n# 누락된 경우 PATH 추가\nexport PATH=$PATH:$(go env GOPATH)/bin\n```\n\n2. `permission denied`\n\n```bash\n# 실행 권한 추가\nchmod +x $(which protoc)\nchmod +x $(which protoc-gen-go)\nchmod +x $(which protoc-gen-go-grpc)\n```\n\n3. `missing go_package option`\n\n```protobuf\n// proto 파일에 go_package 옵션 추가\noption go_package = \"example/package\";\n```\n\n## 버전 호환성\n\n### 권장 버전 조합\n\n- protoc: 3.21.0 이상\n- protoc-gen-go: v1.28.0 이상\n- protoc-gen-go-grpc: v1.2.0 이상\n\n### 버전 확인 명령어\n\n```bash\n# 모든 컴포넌트 버전 확인\nprotoc --version\nprotoc-gen-go --version\ngo list -m google.golang.org/grpc\n```\n\n### gRPC 참고 링크\n\n#### protoc\n\n[https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)\n\n#### protoc-gen-go\n\n[https://github.com/protocolbuffers/protobuf-go/releases](https://github.com/protocolbuffers/protobuf-go/releases)\n\n#### protoc-gen-go-grpc\n\n[https://pkg.go.dev/google.golang.org/grpc/cmd/protoc-gen-go-grpc](https://pkg.go.dev/google.golang.org/grpc/cmd/protoc-gen-go-grpc)\n"},{"excerpt":"Protocol Buffers와 gRPC 설정 가이드 필요한 도구 설치 1. Protocol Buffers 컴파일러 (protoc) 설치 protoc 릴리즈 페이지에서 운영체제에 맞는 버전을 다운로드합니다. Windows 설치  다운로드 압축 해제  디렉토리를 시스템 PATH에 추가 Linux/macOS 설치 2. Go 플러그인 설치 protoc-gen-…","fields":{"slug":"/protobuf-grpc-guide/"},"frontmatter":{"date":"December 13, 2024","title":"Protocol Buffers와 gRPC 설정 가이드","tags":["Protocol Buffers","gRPC","Go","Compiler"]},"rawMarkdownBody":"\n# Protocol Buffers와 gRPC 설정 가이드\n\n## 필요한 도구 설치\n\n### 1. Protocol Buffers 컴파일러 (protoc) 설치\n\n[protoc 릴리즈 페이지](https://github.com/protocolbuffers/protobuf/releases)에서 운영체제에 맞는 버전을 다운로드합니다.\n\n#### Windows 설치\n\n1. `protoc-{version}-win64.zip` 다운로드\n2. 압축 해제\n3. `bin` 디렉토리를 시스템 PATH에 추가\n\n#### Linux/macOS 설치\n\n```bash\n# macOS (Homebrew)\nbrew install protobuf\n\n# Linux (apt)\napt-get install protobuf-compiler\n\n# Linux (yum)\nyum install protobuf-compiler\n```\n\n### 2. Go 플러그인 설치\n\n#### protoc-gen-go 설치\n\n[protoc-gen-go 릴리즈](https://github.com/protocolbuffers/protobuf-go/releases)에서 최신 버전을 확인하고 설치합니다.\n\n```bash\n# Go 1.16 이상\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 특정 버전 설치\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28\n```\n\n#### protoc-gen-go-grpc 설치\n\n[protoc-gen-go-grpc 문서](https://pkg.go.dev/google.golang.org/grpc/cmd/protoc-gen-go-grpc)를 참고하여 설치합니다.\n\n```bash\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n```\n\n## 프로젝트 구조 설정\n\n```\nyour-project/\n├── proto/\n│   └── service/\n│       └── service.proto\n├── gen/\n│   └── service/\n├── cmd/\n│   └── server/\n│       └── main.go\n└── go.mod\n```\n\n## Proto 파일 작성 예시\n\n```protobuf\n// proto/service/service.proto\nsyntax = \"proto3\";\n\npackage service;\n\noption go_package = \"your-project/gen/service\";\n\nservice GreeterService {\n  rpc SayHello (HelloRequest) returns (HelloResponse) {}\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloResponse {\n  string message = 1;\n}\n```\n\n## 컴파일 명령어\n\n### 기본 컴파일 명령어\n\n```bash\nprotoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    proto/service/service.proto\n```\n\n### 옵션 설명\n\n- `--go_out=.`: Go 코드 생성 출력 디렉토리\n- `--go_opt=paths=source_relative`: 소스 파일 기준 상대 경로 사용\n- `--go-grpc_out=.`: gRPC 코드 생성 출력 디렉토리\n- `--go-grpc_opt=paths=source_relative`: gRPC 코드에 대한 상대 경로 사용\n\n### 여러 Proto 파일 컴파일\n\n```bash\nprotoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    proto/service/*.proto\n```\n\n### Makefile 활용\n\n```makefile\n.PHONY: proto\nproto:\n    protoc --go_out=. --go_opt=paths=source_relative \\\n        --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n        proto/service/*.proto\n```\n\n## 생성된 코드 사용\n\n### 서버 구현 예시\n\n```go\n// cmd/server/main.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    pb \"your-project/gen/service\"\n    \"google.golang.org/grpc\"\n)\n\ntype server struct {\n    pb.UnimplementedGreeterServiceServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error) {\n    return &pb.HelloResponse{\n        Message: \"Hello \" + req.Name,\n    }, nil\n}\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":50051\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n\n    s := grpc.NewServer()\n    pb.RegisterGreeterServiceServer(s, &server{})\n\n    log.Printf(\"server listening at %v\", lis.Addr())\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n}\n```\n\n### 클라이언트 구현 예시\n\n```go\n// cmd/client/main.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    pb \"your-project/gen/service\"\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    conn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n\n    c := pb.NewGreeterServiceClient(conn)\n\n    ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n    defer cancel()\n\n    r, err := c.SayHello(ctx, &pb.HelloRequest{Name: \"World\"})\n    if err != nil {\n        log.Fatalf(\"could not greet: %v\", err)\n    }\n    log.Printf(\"Greeting: %s\", r.GetMessage())\n}\n```\n\n## 주요 문제 해결\n\n### 1. PATH 설정 문제\n\n```bash\n# Go bin 디렉토리를 PATH에 추가\nexport PATH=$PATH:$(go env GOPATH)/bin\n```\n\n### 2. 컴파일 오류 해결\n\n```bash\n# 플러그인 설치 확인\nwhich protoc-gen-go\nwhich protoc-gen-go-grpc\n\n# 버전 확인\nprotoc --version\nprotoc-gen-go --version\n```\n\n### 3. Import 경로 문제\n\n```protobuf\n// 올바른 import 경로 설정\noption go_package = \"github.com/username/project/gen/service\";\n```\n\n## 모범 사례\n\n1. **버전 관리**\n\n   - Proto 파일의 버전을 명시적으로 관리\n   - API 변경 시 하위 호환성 유지\n\n2. **구조화**\n\n   ```\n   proto/\n   ├── v1/\n   │   └── service.proto\n   └── v2/\n       └── service.proto\n   ```\n\n3. **문서화**\n\n   ```protobuf\n   // service.proto\n   // Service for handling user operations\n   service UserService {\n     // CreateUser creates a new user\n     // Returns the created user information\n     rpc CreateUser (CreateUserRequest) returns (CreateUserResponse) {}\n   }\n   ```\n\n4. **재사용**\n   ```protobuf\n   // common.proto\n   message Timestamp {\n     int64 seconds = 1;\n     int32 nanos = 2;\n   }\n   ```\n\n## 배포 고려사항\n\n1. **버전 호환성**\n\n   - 기존 필드 제거하지 않기\n   - 새로운 필드는 선택적으로 추가\n   - 필드 번호 재사용하지 않기\n\n2. **성능 최적화**\n\n   - 메시지 크기 최소화\n   - 적절한 필드 타입 선택\n   - 불필요한 중첩 피하기\n\n3. **보안**\n   - TLS/SSL 설정\n   - 인증 메커니즘 구현\n   - 접근 제어 설정\n"},{"excerpt":"AWS EC2를 통해 RDS SSH 터널링 설정 가이드 이 가이드는 AWS EC2 서버를 통해 RDS 데이터베이스에 접속하고, 로컬에서 안전하게 접근할 수 있도록 SSH 터널링을 설정하는 방법을 설명합니다. 사전 준비 EC2 서버 정보: 공용 IP (예: ) SSH 키 파일 (예: ) 사용자 (,  등) RDS 정보: 엔드포인트 (예: ) 포트 (은 My…","fields":{"slug":"/AWS_EC2_to_RDS_Tunneling_Guide_KR/"},"frontmatter":{"date":"December 13, 2024","title":"AWS EC2를 통해 RDS SSH 터널링 설정 가이드","tags":["AWS","RDS"]},"rawMarkdownBody":"\n# AWS EC2를 통해 RDS SSH 터널링 설정 가이드\n\n이 가이드는 AWS EC2 서버를 통해 RDS 데이터베이스에 접속하고, 로컬에서 안전하게 접근할 수 있도록 SSH 터널링을 설정하는 방법을 설명합니다.\n\n---\n\n## 사전 준비\n\n1. **EC2 서버 정보**:\n\n   - 공용 IP (예: `54.123.45.67`)\n   - SSH 키 파일 (예: `aws-key.pem`)\n   - 사용자 (`ec2-user`, `ubuntu` 등)\n\n2. **RDS 정보**:\n\n   - 엔드포인트 (예: `mydb.xxxxx.us-east-1.rds.amazonaws.com`)\n   - 포트 (`3306`은 MySQL, `5432`는 PostgreSQL)\n   - 데이터베이스 사용자명 및 비밀번호\n\n3. **로컬 머신**:\n   - 터널링에 사용할 로컬 포트 (예: `3306`)\n\n---\n\n## 1단계: EC2 서버로 SSH 접속\n\n로컬 머신에서 EC2 서버로 SSH 접속:\n\n```bash\nssh -i /path/to/aws-key.pem ec2-user@54.123.45.67\n```\n\n---\n\n## 2단계: EC2에서 RDS 연결 테스트\n\nEC2 서버에서 RDS 서버에 연결 가능한지 확인합니다.\n\n### (1) Ping 테스트 (허용되는 경우):\n\n```bash\nping mydb.xxxxx.us-east-1.rds.amazonaws.com\n```\n\n### (2) 데이터베이스 연결 테스트:\n\n#### MySQL의 경우:\n\n```bash\nmysql -h mydb.xxxxx.us-east-1.rds.amazonaws.com -P 3306 -u <db_user> -p\n```\n\n#### PostgreSQL의 경우:\n\n```bash\npsql -h mydb.xxxxx.us-east-1.rds.amazonaws.com -p 5432 -U <db_user> <db_name>\n```\n\n---\n\n## 3단계: SSH 터널링 설정\n\nEC2 서버를 통해 로컬 머신에서 RDS에 접근할 수 있도록 SSH 터널링을 설정합니다.\n\n### 명령어:\n\n```bash\nssh -i /path/to/aws-key.pem -L <local_port>:<rds_endpoint>:<db_port> ec2-user@<ec2_public_ip>\n```\n\n### 예제:\n\n```bash\nssh -i aws-key.pem -L 3306:mydb.xxxxx.us-east-1.rds.amazonaws.com:3306 ec2-user@54.123.45.67\n```\n\n- **`3306`**: 로컬 머신에서 사용할 포트\n- **`mydb.xxxxx.us-east-1.rds.amazonaws.com`**: RDS 엔드포인트\n- **`3306`**: RDS 포트 (여기서는 MySQL)\n\n---\n\n## 4단계: 로컬에서 데이터베이스 접속\n\nSSH 터널링이 설정되면 로컬 머신에서 RDS 데이터베이스에 접속합니다.\n\n### MySQL 클라이언트를 사용하는 경우:\n\n```bash\nmysql -h 127.0.0.1 -P 3306 -u <db_user> -p\n```\n\n### PostgreSQL 클라이언트를 사용하는 경우:\n\n```bash\npsql -h 127.0.0.1 -p 3306 -U <db_user> <db_name>\n```\n\n### GUI 클라이언트를 사용하는 경우:\n\n- 호스트: `127.0.0.1`\n- 포트: `3306`\n- 사용자명: 데이터베이스 사용자명\n- 비밀번호: 데이터베이스 비밀번호\n\n---\n\n## 5단계: SSH Config로 자동화\n\n매번 명령어를 실행하지 않으려면 SSH 설정 파일을 활용할 수 있습니다.\n\n### 구성 예제:\n\n`~/.ssh/config` 파일에 아래 내용을 추가:\n\n```plaintext\nHost aws-ec2\n    HostName 54.123.45.67\n    User ec2-user\n    IdentityFile /path/to/aws-key.pem\n    LocalForward 3306 mydb.xxxxx.us-east-1.rds.amazonaws.com:3306\n```\n\n### 실행:\n\n```bash\nssh aws-ec2\n```\n\n---\n\n## 문제 해결\n\n### 문제 1: EC2에서 RDS 연결 실패\n\n#### 원인:\n\n- RDS 보안 그룹이 EC2 서버의 프라이빗 IP를 허용하지 않을 수 있음.\n\n#### 해결:\n\n- RDS 보안 그룹에 아래와 같은 인바운드 규칙 추가:\n  - **타입**: MySQL/Aurora 또는 PostgreSQL\n  - **프로토콜**: TCP\n  - **포트 범위**: `3306` (또는 `5432`)\n  - **소스**: EC2 프라이빗 IP (예: `172.31.0.5/32`)\n\n### 문제 2: 로컬에서 RDS 연결 실패\n\n#### 원인:\n\n- SSH 터널링이 제대로 설정되지 않음.\n\n#### 해결:\n\n- 터널링 상태 확인:\n  ```bash\n  netstat -an | grep 3306\n  ```\n- 다른 포트를 사용해 충돌 방지:\n  ```bash\n  ssh -i aws-key.pem -L 3307:mydb.xxxxx.us-east-1.rds.amazonaws.com:3306 ec2-user@54.123.45.67\n  ```\n\n---\n\n## 요약\n\n1. **EC2에 SSH 접속**:\n\n   ```bash\n   ssh -i aws-key.pem ec2-user@54.123.45.67\n   ```\n\n2. **EC2에서 RDS 연결 테스트**:\n\n   ```bash\n   mysql -h mydb.xxxxx.us-east-1.rds.amazonaws.com -P 3306 -u <db_user> -p\n   ```\n\n3. **SSH 터널링 설정**:\n\n   ```bash\n   ssh -i aws-key.pem -L 3306:mydb.xxxxx.us-east-1.rds.amazonaws.com:3306 ec2-user@54.123.45.67\n   ```\n\n4. **로컬에서 데이터베이스 접속**:\n   ```bash\n   mysql -h 127.0.0.1 -P 3306 -u <db_user> -p\n   ```\n\n---\n\n## 참고 자료\n\n- AWS EC2 문서\n- AWS RDS 문서\n"},{"excerpt":"Windows 가상 환경(venv) 활성화 문제 해결 가이드 일반적인 오류 상황 Windows에서 가상 환경 활성화 시 다음과 같은 오류들이 자주 발생합니다: \"activate.ps1은 현재 시스템에서 스크립트를 실행할 수 없기 때문에 로드할 수 없습니다.\" \"이 시스템에서 스크립트를 실행할 수 없으므로 ... 파일을 로드할 수 없습니다.\" \"venv\\S…","fields":{"slug":"/windows-venv-guide/"},"frontmatter":{"date":"December 13, 2024","title":"Windows 가상 환경(venv) 활성화 문제 해결 가이드","tags":["Python","Windows"]},"rawMarkdownBody":"\n# Windows 가상 환경(venv) 활성화 문제 해결 가이드\n\n## 일반적인 오류 상황\n\nWindows에서 가상 환경 활성화 시 다음과 같은 오류들이 자주 발생합니다:\n\n1. \"activate.ps1은 현재 시스템에서 스크립트를 실행할 수 없기 때문에 로드할 수 없습니다.\"\n2. \"이 시스템에서 스크립트를 실행할 수 없으므로 ... 파일을 로드할 수 없습니다.\"\n3. \"venv\\Scripts\\activate.ps1 파일이 없습니다.\"\n\n## 해결 방법\n\n### 1. PowerShell 실행 정책 변경\n\nPowerShell을 관리자 권한으로 실행하고 다음 명령어를 실행합니다:\n\n```powershell\n# 현재 실행 정책 확인\nGet-ExecutionPolicy\n\n# 실행 정책 변경\nSet-ExecutionPolicy RemoteSigned\n\n# 사용자 범위로 실행 정책 변경 (더 안전한 방법)\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n### 2. 올바른 가상 환경 활성화 방법\n\n```powershell\n# PowerShell에서 활성화\n.\\venv\\Scripts\\activate.ps1\n\n# Command Prompt(cmd)에서 활성화\n.\\venv\\Scripts\\activate.bat\n\n# Git Bash에서 활성화\nsource venv/Scripts/activate\n```\n\n### 3. 가상 환경 재생성\n\n문제가 지속될 경우 가상 환경을 삭제하고 재생성합니다:\n\n```powershell\n# 기존 가상 환경 삭제\nRemove-Item -Recurse -Force venv\n\n# 새 가상 환경 생성\npython -m venv venv\n```\n\n### 4. Python 경로 문제 해결\n\n시스템 환경 변수에 Python 경로가 제대로 설정되어 있는지 확인:\n\n1. 시스템 속성 → 고급 → 환경 변수\n2. Path 변수에 다음 경로들이 있는지 확인:\n   ```\n   C:\\Users\\{사용자명}\\AppData\\Local\\Programs\\Python\\Python3x\\\n   C:\\Users\\{사용자명}\\AppData\\Local\\Programs\\Python\\Python3x\\Scripts\\\n   ```\n\n### 5. Visual Studio Code에서의 해결 방법\n\n1. VS Code 터미널 설정 변경:\n\n   - `Ctrl + Shift + P` → \"Terminal: Select Default Profile\" 선택\n   - \"Command Prompt\" 또는 \"PowerShell\" 선택\n\n2. 가상 환경 인터프리터 선택:\n   - `Ctrl + Shift + P` → \"Python: Select Interpreter\" 선택\n   - 생성한 가상 환경 선택 (./venv/Scripts/python.exe)\n\n## 자주 발생하는 문제별 해결 방법\n\n### 1. Permission Error 해결\n\n```powershell\n# PowerShell을 관리자 권한으로 실행 후\nSet-ExecutionPolicy Unrestricted -Force\n```\n\n### 2. 경로 문제 해결\n\n```powershell\n# 현재 위치 확인\npwd\n\n# 가상 환경이 있는 디렉토리로 이동\ncd your-project-directory\n\n# 상대 경로로 활성화\n.\\venv\\Scripts\\activate\n```\n\n### 3. 파일 인코딩 문제 해결\n\n가상 환경 스크립트 파일이 잘못된 인코딩으로 저장된 경우:\n\n1. `activate.ps1` 파일을 메모장으로 열기\n2. \"다른 이름으로 저장\" 선택\n3. 인코딩을 \"UTF-8\"로 설정하여 저장\n\n### 4. pip 관련 문제 해결\n\n```powershell\n# pip 업그레이드\npython -m pip install --upgrade pip\n\n# pip 재설치\npython -m pip uninstall pip\npython -m ensurepip\npython -m pip install --upgrade pip\n```\n\n## 모범 사례\n\n### 1. 프로젝트 구조\n\n```\nyour-project/\n├── venv/\n├── src/\n├── requirements.txt\n└── README.md\n```\n\n### 2. 가상 환경 생성 스크립트\n\n`create_venv.bat` 파일 생성:\n\n```batch\n@echo off\npython -m venv venv\ncall venv\\Scripts\\activate.bat\npython -m pip install --upgrade pip\npip install -r requirements.txt\necho Virtual environment setup complete!\n```\n\n### 3. 자동 활성화 설정\n\nPowerShell 프로필에 다음 함수 추가:\n\n```powershell\n# $PROFILE 파일에 추가\nfunction activate-venv {\n    if (Test-Path \"venv\\Scripts\\activate.ps1\") {\n        .\\venv\\Scripts\\activate.ps1\n    } else {\n        Write-Host \"No venv found in current directory\"\n    }\n}\n```\n\n## 보안 고려사항\n\n1. 실행 정책을 변경할 때는 보안 위험을 고려하세요.\n2. 가능하면 `RemoteSigned`를 사용하고, `Unrestricted`는 피하세요.\n3. 사용자 범위(`-Scope CurrentUser`)로 제한하는 것이 좋습니다.\n\n## 추가 팁\n\n1. **가상 환경 이름 표시 확인**\n\n   ```powershell\n   # 활성화 성공 시 프롬프트 앞에 (venv)가 표시됨\n   (venv) PS C:\\your-project>\n   ```\n\n2. **Python 버전 확인**\n\n   ```powershell\n   python --version\n   # 가상 환경의 Python 버전이 맞는지 확인\n   ```\n\n3. **의존성 관리**\n\n   ```powershell\n   # 설치된 패키지 목록 저장\n   pip freeze > requirements.txt\n\n   # 패키지 설치\n   pip install -r requirements.txt\n   ```\n\n문제가 지속되면 Python을 완전히 제거하고 재설치하는 것도 고려해볼 수 있습니다.\n"},{"excerpt":"SSH Tunneling을 활용한 Python MySQL 연결 가이드 개요 SSH Tunneling은 보안 연결을 통해 원격 데이터베이스에 안전하게 접근할 수 있게 해주는 기술입니다. 이 가이드에서는 Python을 사용하여 SSH Tunnel을 통해 MySQL 데이터베이스에 연결하는 방법을 설명합니다. 필요 패키지 설치 기본 연결 설정 1. 단순 SSH …","fields":{"slug":"/ssh-mysql-python/"},"frontmatter":{"date":"December 13, 2024","title":"SSH Tunneling을 활용한 Python MySQL 연결 가이드","tags":["Python","MySQL"]},"rawMarkdownBody":"\n# SSH Tunneling을 활용한 Python MySQL 연결 가이드\n\n## 개요\n\nSSH Tunneling은 보안 연결을 통해 원격 데이터베이스에 안전하게 접근할 수 있게 해주는 기술입니다. 이 가이드에서는 Python을 사용하여 SSH Tunnel을 통해 MySQL 데이터베이스에 연결하는 방법을 설명합니다.\n\n## 필요 패키지 설치\n\n```bash\npip install sshtunnel\npip install pymysql\npip install cryptography\n```\n\n## 기본 연결 설정\n\n### 1. 단순 SSH Tunnel 연결\n\n```python\nimport pymysql\nfrom sshtunnel import SSHTunnelForwarder\n\n# SSH Tunnel 설정\nssh_tunnel = SSHTunnelForwarder(\n    'remote_host',  # SSH 서버 주소\n    ssh_username='ssh_user',\n    ssh_password='ssh_password',  # 또는 ssh_pkey='/path/to/private/key'\n    remote_bind_address=('127.0.0.1', 3306)  # MySQL 서버 주소와 포트\n)\n\n# Tunnel 시작\nssh_tunnel.start()\n\ntry:\n    # MySQL 연결\n    connection = pymysql.connect(\n        host='127.0.0.1',\n        port=ssh_tunnel.local_bind_port,\n        user='mysql_user',\n        password='mysql_password',\n        database='database_name'\n    )\n\n    with connection.cursor() as cursor:\n        cursor.execute('SELECT version()')\n        result = cursor.fetchone()\n        print(f'MySQL 버전: {result[0]}')\n\nfinally:\n    # 연결 종료\n    if 'connection' in locals():\n        connection.close()\n    ssh_tunnel.close()\n```\n\n### 2. SSH 키 인증 사용\n\n```python\nfrom pathlib import Path\nimport pymysql\nfrom sshtunnel import SSHTunnelForwarder\n\n# SSH 키 경로 설정\nssh_key = Path.home() / '.ssh' / 'id_rsa'\n\n# SSH Tunnel 설정\nssh_tunnel = SSHTunnelForwarder(\n    'remote_host',\n    ssh_username='ssh_user',\n    ssh_pkey=str(ssh_key),\n    ssh_private_key_password='key_password',  # 키가 암호화되어 있는 경우\n    remote_bind_address=('127.0.0.1', 3306)\n)\n\nssh_tunnel.start()\n# ... 이하 동일\n```\n\n## 실용적인 구현 예제\n\n### 1. 컨텍스트 매니저 활용\n\n```python\nfrom contextlib import contextmanager\nimport pymysql\nfrom sshtunnel import SSHTunnelForwarder\n\nclass DatabaseConnection:\n    def __init__(self, ssh_config, db_config):\n        self.ssh_config = ssh_config\n        self.db_config = db_config\n        self.tunnel = None\n        self.connection = None\n\n    @contextmanager\n    def connect(self):\n        try:\n            # SSH Tunnel 설정\n            self.tunnel = SSHTunnelForwarder(\n                self.ssh_config['host'],\n                ssh_username=self.ssh_config['user'],\n                ssh_pkey=self.ssh_config['key_path'],\n                remote_bind_address=(\n                    self.db_config['host'],\n                    self.db_config['port']\n                )\n            )\n\n            self.tunnel.start()\n\n            # 데이터베이스 연결\n            connection = pymysql.connect(\n                host='127.0.0.1',\n                port=self.tunnel.local_bind_port,\n                user=self.db_config['user'],\n                password=self.db_config['password'],\n                database=self.db_config['database'],\n                cursorclass=pymysql.cursors.DictCursor\n            )\n\n            yield connection\n\n        finally:\n            if connection:\n                connection.close()\n            if self.tunnel:\n                self.tunnel.close()\n\n# 사용 예제\nssh_config = {\n    'host': 'remote_host',\n    'user': 'ssh_user',\n    'key_path': '/path/to/private/key'\n}\n\ndb_config = {\n    'host': '127.0.0.1',\n    'port': 3306,\n    'user': 'mysql_user',\n    'password': 'mysql_password',\n    'database': 'database_name'\n}\n\ndb = DatabaseConnection(ssh_config, db_config)\n\n# 데이터베이스 작업 수행\nwith db.connect() as conn:\n    with conn.cursor() as cursor:\n        cursor.execute('SELECT * FROM users')\n        users = cursor.fetchall()\n        print(users)\n```\n\n### 2. 연결 풀링 구현\n\n```python\nfrom queue import Queue\nimport threading\nimport pymysql\nfrom sshtunnel import SSHTunnelForwarder\n\nclass ConnectionPool:\n    def __init__(self, ssh_config, db_config, pool_size=5):\n        self.ssh_config = ssh_config\n        self.db_config = db_config\n        self.pool_size = pool_size\n        self.pool = Queue(maxsize=pool_size)\n        self.lock = threading.Lock()\n        self.tunnel = None\n        self._initialize_pool()\n\n    def _initialize_pool(self):\n        # SSH Tunnel 설정\n        self.tunnel = SSHTunnelForwarder(\n            self.ssh_config['host'],\n            ssh_username=self.ssh_config['user'],\n            ssh_pkey=self.ssh_config['key_path'],\n            remote_bind_address=(\n                self.db_config['host'],\n                self.db_config['port']\n            )\n        )\n        self.tunnel.start()\n\n        # 연결 풀 생성\n        for _ in range(self.pool_size):\n            connection = pymysql.connect(\n                host='127.0.0.1',\n                port=self.tunnel.local_bind_port,\n                user=self.db_config['user'],\n                password=self.db_config['password'],\n                database=self.db_config['database'],\n                cursorclass=pymysql.cursors.DictCursor\n            )\n            self.pool.put(connection)\n\n    @contextmanager\n    def get_connection(self):\n        connection = self.pool.get()\n        try:\n            yield connection\n        finally:\n            if connection:\n                self.pool.put(connection)\n\n    def close(self):\n        while not self.pool.empty():\n            connection = self.pool.get()\n            connection.close()\n        if self.tunnel:\n            self.tunnel.close()\n\n# 사용 예제\npool = ConnectionPool(ssh_config, db_config)\n\ntry:\n    with pool.get_connection() as conn:\n        with conn.cursor() as cursor:\n            cursor.execute('SELECT * FROM users')\n            users = cursor.fetchall()\n            print(users)\nfinally:\n    pool.close()\n```\n\n## 에러 처리\n\n```python\nimport logging\nfrom pymysql.err import OperationalError, Error as PyMySQLError\nfrom sshtunnel import BaseSSHTunnelForwarderError\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef execute_query(connection_pool, query, params=None):\n    try:\n        with connection_pool.get_connection() as conn:\n            with conn.cursor() as cursor:\n                cursor.execute(query, params or ())\n                return cursor.fetchall()\n\n    except OperationalError as e:\n        logger.error(f\"데이터베이스 연결 오류: {e}\")\n        raise\n\n    except PyMySQLError as e:\n        logger.error(f\"쿼리 실행 오류: {e}\")\n        raise\n\n    except BaseSSHTunnelForwarderError as e:\n        logger.error(f\"SSH Tunnel 오류: {e}\")\n        raise\n\n    except Exception as e:\n        logger.error(f\"예상치 못한 오류: {e}\")\n        raise\n```\n\n## 보안 고려사항\n\n1. **SSH 키 관리**\n\n   - 키 파일 권한 설정\n\n   ```bash\n   chmod 600 ~/.ssh/id_rsa\n   ```\n\n   - 키 파일 암호화 사용\n\n2. **환경 변수 활용**\n\n   ```python\n   import os\n   from dotenv import load_dotenv\n\n   load_dotenv()\n\n   ssh_config = {\n       'host': os.getenv('SSH_HOST'),\n       'user': os.getenv('SSH_USER'),\n       'key_path': os.getenv('SSH_KEY_PATH')\n   }\n   ```\n\n3. **연결 타임아웃 설정**\n   ```python\n   ssh_tunnel = SSHTunnelForwarder(\n       'remote_host',\n       ssh_username='ssh_user',\n       ssh_pkey='/path/to/private/key',\n       remote_bind_address=('127.0.0.1', 3306),\n       timeout=15.0  # 연결 타임아웃 설정\n   )\n   ```\n\n## 성능 최적화 팁\n\n1. **연결 재사용**\n\n   - 가능한 한 연결 풀 사용\n   - 장기 실행 스크립트의 경우 연결 상태 모니터링\n\n2. **배치 처리**\n\n   ```python\n   def batch_insert(connection_pool, records, batch_size=1000):\n       with connection_pool.get_connection() as conn:\n           with conn.cursor() as cursor:\n               for i in range(0, len(records), batch_size):\n                   batch = records[i:i + batch_size]\n                   cursor.executemany(\n                       \"INSERT INTO table_name (column1, column2) \"\n                       \"VALUES (%s, %s)\",\n                       batch\n                   )\n               conn.commit()\n   ```\n\n3. **비동기 처리 구현**\n\n   ```python\n   import asyncio\n   import aiomysql\n   from asyncssh import connect as ssh_connect\n\n   async def async_query(pool, query):\n       async with pool.acquire() as conn:\n           async with conn.cursor() as cursor:\n               await cursor.execute(query)\n               return await cursor.fetchall()\n   ```\n\n## 마치며\n\nSSH Tunneling을 통한 MySQL 연결은 보안성과 안정성을 모두 갖춘 접근 방식입니다. 실제 운영 환경에서는 연결 풀링, 에러 처리, 보안 설정 등을 종합적으로 고려하여 구현해야 합니다.\n\n다음 글에서는 SSH Tunneling을 활용한 고급 데이터베이스 작업과 성능 최적화 기법에 대해 더 자세히 알아보도록 하겠습니다.\n"},{"excerpt":"MongoDB Replica Set 인증키 설정 가이드 인증키의 중요성 MongoDB Replica Set 구성 시 멤버 간 보안 통신을 위해 인증키가 필요합니다. 이 키는 Replica Set의 모든 멤버가 공유하며, 상호 인증에 사용됩니다. 인증키 생성 및 설정 과정 1. 인증키 생성 2. Docker 환경에서의 권한 문제 Docker 컨테이너에서 M…","fields":{"slug":"/mongodb-auth-key/"},"frontmatter":{"date":"December 13, 2024","title":"MongoDB Replica Set 인증키 설정 가이드","tags":["MongoDB","ReplicaSet","Security","Docker"]},"rawMarkdownBody":"\n# MongoDB Replica Set 인증키 설정 가이드\n\n## 인증키의 중요성\n\nMongoDB Replica Set 구성 시 멤버 간 보안 통신을 위해 인증키가 필요합니다. 이 키는 Replica Set의 모든 멤버가 공유하며, 상호 인증에 사용됩니다.\n\n## 인증키 생성 및 설정 과정\n\n### 1. 인증키 생성\n\n```bash\n# 충분한 길이의 랜덤 키 생성\nopenssl rand -base64 756 > mongo_key.sec\n\n# 키 파일 권한 설정 (읽기 전용)\nchmod 400 mongo_key.sec\n```\n\n### 2. Docker 환경에서의 권한 문제\n\nDocker 컨테이너에서 MongoDB를 실행할 때 키 파일 접근 권한으로 인한 오류가 자주 발생합니다.\n\n#### 일반적인 오류 메시지\n\n```\nError: KeyFile must have file permissions set to 400 (only owner may read)\n```\n\n#### 해결 방법\n\n```bash\n# MongoDB 시스템 사용자에게 키 파일 소유권 부여\nsudo chown systemd-coredump mongo_key.sec\n```\n\n### 3. Docker Compose 설정 예시\n\n```yaml\nversion: '3.8'\n\nservices:\n  mongo1:\n    image: mongo:latest\n    command: mongod --keyFile /etc/mongodb/mongo_key.sec --replSet rs0 --bind_ip_all\n    volumes:\n      - ./mongo_key.sec:/etc/mongodb/mongo_key.sec:ro\n      - mongo1_data:/data/db\n\n  mongo2:\n    image: mongo:latest\n    command: mongod --keyFile /etc/mongodb/mongo_key.sec --replSet rs0 --bind_ip_all\n    volumes:\n      - ./mongo_key.sec:/etc/mongodb/mongo_key.sec:ro\n      - mongo2_data:/data/db\n\n  mongo3:\n    image: mongo:latest\n    command: mongod --keyFile /etc/mongodb/mongo_key.sec --replSet rs0 --bind_ip_all\n    volumes:\n      - ./mongo_key.sec:/etc/mongodb/mongo_key.sec:ro\n      - mongo3_data:/data/db\n\nvolumes:\n  mongo1_data:\n  mongo2_data:\n  mongo3_data:\n```\n\n## 주의사항\n\n1. 키 파일은 반드시 안전한 방법으로 관리해야 합니다\n2. 키 파일은 모든 Replica Set 멤버에서 동일한 내용이어야 합니다\n3. 키 파일의 권한은 반드시 400(읽기 전용)이어야 합니다\n4. Docker 환경에서는 볼륨 마운트 시 `:ro` 옵션을 사용하여 읽기 전용으로 마운트합니다\n\n## 보안 강화 팁\n\n1. 정기적으로 키를 교체합니다\n2. 키 파일은 버전 관리 시스템에 직접 포함시키지 않습니다\n3. 운영 환경에서는 보안 키 관리 시스템 사용을 고려합니다\n4. 키 파일 백업은 암호화하여 별도로 보관합니다\n\n## 트러블슈팅\n\n만약 권한 설정 후에도 문제가 계속되면 다음을 확인하세요:\n\n1. SELinux 설정 확인\n2. Docker 볼륨 마운트 권한 확인\n3. 호스트 시스템의 사용자/그룹 ID 확인\n4. Docker 컨테이너 내부의 MongoDB 프로세스 권한 확인\n"},{"excerpt":"Celery 개발 문서 목차 Celery 소개 설치 및 기본 설정 Celery 애플리케이션 구성 작업(Task) 생성 및 실행 메시지 브로커 설정 결과 백엔드 설정 Celery Beat로 주기적 작업 관리 고급 기능 태스크 체이닝 및 워크플로 작업 재시도 작업 우선순위 Celery 모니터링 Celery 최적화 및 성능 튜닝 예제 프로젝트 1. Celery…","fields":{"slug":"/Celery-tip/"},"frontmatter":{"date":"December 13, 2024","title":"Celery 개발 문서","tags":["Python","Celery","AsyncIO","Redis","RabbitMQ"]},"rawMarkdownBody":"\n### **Celery 개발 문서**\n\n---\n\n### **목차**\n\n1. Celery 소개\n2. 설치 및 기본 설정\n3. Celery 애플리케이션 구성\n4. 작업(Task) 생성 및 실행\n5. 메시지 브로커 설정\n6. 결과 백엔드 설정\n7. Celery Beat로 주기적 작업 관리\n8. 고급 기능\n   - 태스크 체이닝 및 워크플로\n   - 작업 재시도\n   - 작업 우선순위\n9. Celery 모니터링\n10. Celery 최적화 및 성능 튜닝\n11. 예제 프로젝트\n\n---\n\n### **1. Celery 소개**\n\nCelery는 **비동기 작업 큐**를 구현하는 Python 분산 시스템으로, 실시간 작업 처리와 대규모 작업 처리를 지원합니다.  \n주요 특징:\n\n- 분산 가능\n- 작업 재시도 및 결과 추적 가능\n- 메시지 브로커(Redis, RabbitMQ 등)와 통합\n\n---\n\n### **2. 설치 및 기본 설정**\n\n#### **설치**\n\nCelery와 Redis를 설치합니다:\n\n```bash\npip install celery[redis]\n```\n\n#### **기본 폴더 구조**\n\n```plaintext\nproject/\n├── tasks.py          # Celery 작업 정의\n├── celery_app.py     # Celery 애플리케이션 구성\n├── requirements.txt  # 종속성\n└── worker.log        # 로그 파일\n```\n\n---\n\n### **3. Celery 애플리케이션 구성**\n\n#### **celery_app.py**\n\n```python\nfrom celery import Celery\n\n# Celery 애플리케이션 생성\napp = Celery(\n    'my_project',\n    broker='redis://localhost:6379/0',  # 메시지 브로커 URL\n    backend='redis://localhost:6379/0'  # 결과 백엔드 URL\n)\n\n# 기본 설정\napp.conf.update(\n    task_serializer='json',\n    result_serializer='json',\n    accept_content=['json'],\n    timezone='UTC',\n    enable_utc=True,\n)\n```\n\n---\n\n### **4. 작업(Task) 생성 및 실행**\n\n#### **tasks.py**\n\n```python\nfrom celery_app import app\n\n@app.task\ndef add(x, y):\n    return x + y\n\n@app.task\ndef multiply(x, y):\n    return x * y\n```\n\n#### **작업 실행**\n\n- **Celery 워커 시작**\n\n```bash\ncelery -A celery_app worker --loglevel=info\n```\n\n- **작업 호출**\n\n```python\nfrom tasks import add\n\nresult = add.delay(3, 5)  # 작업을 비동기적으로 호출\nprint(result.get())      # 결과 확인\n```\n\n---\n\n### **5. 메시지 브로커 설정**\n\n#### **Redis를 메시지 브로커로 사용**\n\nRedis 설치:\n\n```bash\nsudo apt install redis\n```\n\nCelery 설정:\n\n```python\nbroker_url = 'redis://localhost:6379/0'\n```\n\n#### **RabbitMQ를 메시지 브로커로 사용**\n\nRabbitMQ 설치:\n\n```bash\nsudo apt install rabbitmq-server\n```\n\nCelery 설정:\n\n```python\nbroker_url = 'amqp://guest@localhost//'\n```\n\n---\n\n### **6. 결과 백엔드 설정**\n\n결과 백엔드 설정은 태스크 실행 결과를 저장하고 싶을 때 사용합니다.\n\n- Redis를 결과 백엔드로 설정:\n\n```python\nresult_backend = 'redis://localhost:6379/0'\n```\n\n- 데이터베이스를 결과 백엔드로 설정:\n\n```python\nresult_backend = 'db+sqlite:///results.sqlite3'\n```\n\n---\n\n### **7. Celery Beat로 주기적 작업 관리**\n\n`celery[redis,celerybeat]`를 설치:\n\n```bash\npip install \"celery[redis,celerybeat]\"\n```\n\n#### **celery_app.py 업데이트**\n\n```python\nfrom celery import Celery\nfrom celery.schedules import crontab\n\napp = Celery('my_project', broker='redis://localhost:6379/0')\n\napp.conf.beat_schedule = {\n    'add-every-30-seconds': {\n        'task': 'tasks.add',\n        'schedule': 30.0,  # 30초마다 실행\n        'args': (16, 16)\n    },\n}\n```\n\n#### **Beat 실행**\n\n```bash\ncelery -A celery_app beat --loglevel=info\n```\n\n---\n\n### **8. 고급 기능**\n\n#### **1) 태스크 체이닝 및 워크플로**\n\n```python\nfrom celery import chain\nresult = chain(add.s(2, 2), multiply.s(4)).apply_async()\n```\n\n#### **2) 작업 재시도**\n\n```python\n@app.task(bind=True, max_retries=3)\ndef unreliable_task(self, x):\n    try:\n        # 실패 가능 작업\n        return x / 0\n    except ZeroDivisionError as exc:\n        raise self.retry(exc=exc, countdown=5)\n```\n\n#### **3) 작업 우선순위**\n\n```python\n@app.task(queue='high_priority')\ndef high_priority_task(x):\n    return x * 2\n```\n\n---\n\n### **9. Celery 모니터링**\n\n#### **Flower 설치 및 실행**\n\nFlower는 Celery 작업을 실시간으로 모니터링하는 도구입니다.\n\n```bash\npip install flower\ncelery -A celery_app flower\n```\n\n웹 UI: [http://localhost:5555](http://localhost:5555)\n\n---\n\n### **10. Celery 최적화 및 성능 튜닝**\n\n1. **워크 컨커런시 설정**\n\n   ```bash\n   celery -A celery_app worker --concurrency=4 --loglevel=info\n   ```\n\n2. **태스크 사전 로드**\n\n   ```python\n   app.conf.worker_prefetch_multiplier = 1\n   ```\n\n3. **결과 TTL 설정**\n   ```python\n   app.conf.result_expires = 3600  # 1시간 후 결과 삭제\n   ```\n\n---\n\n### **11. 예제 프로젝트**\n\n#### **간단한 파일 처리**\n\n- **tasks.py**\n\n```python\nfrom celery_app import app\n\n@app.task\ndef process_file(file_path):\n    with open(file_path, 'r') as file:\n        data = file.read()\n    return len(data.split())\n```\n\n- **main.py**\n\n```python\nfrom tasks import process_file\n\nresult = process_file.delay('example.txt')\nprint(f\"Word count: {result.get()}\")\n```\n\n#### **실행**\n\n```bash\ncelery -A celery_app worker --loglevel=info\npython main.py\n```\n\n---\n\nCelery는 **분산 작업 처리**와 **비동기 처리**가 중요한 환경에서 강력한 도구입니다. 이 문서를 기반으로 프로젝트 요구사항에 맞는 Celery 구성을 설계하세요!\n"},{"excerpt":"Celery 개발 가이드 개요 Celery는 Python으로 작성된 분산 태스크 큐 시스템입니다. 비동기 작업 처리, 정기적인 작업 예약, 분산 처리 등을 구현할 수 있습니다. 설치 및 기본 설정 1. 필요 패키지 설치 2. 프로젝트 구조 3. Celery 설정 태스크 정의 1. 기본 태스크 2. 에러 처리와 재시도 태스크 실행 및 모니터링 1. 태스크 …","fields":{"slug":"/celery-guide/"},"frontmatter":{"date":"December 13, 2024","title":"Celery 개발 가이드","tags":["Python","Celery","AsyncIO","Redis","RabbitMQ"]},"rawMarkdownBody":"\n# Celery 개발 가이드\n\n## 개요\n\nCelery는 Python으로 작성된 분산 태스크 큐 시스템입니다. 비동기 작업 처리, 정기적인 작업 예약, 분산 처리 등을 구현할 수 있습니다.\n\n## 설치 및 기본 설정\n\n### 1. 필요 패키지 설치\n\n```bash\n# Celery 및 브로커 설치\npip install celery\npip install \"celery[redis]\"  # Redis 브로커 사용 시\npip install \"celery[rabbitmq]\"  # RabbitMQ 브로커 사용 시\n```\n\n### 2. 프로젝트 구조\n\n```\nmy_project/\n├── celery_app/\n│   ├── __init__.py\n│   ├── celery.py\n│   └── tasks.py\n├── config.py\n└── main.py\n```\n\n### 3. Celery 설정\n\n```python\n# celery_app/celery.py\nfrom celery import Celery\n\n# Celery 인스턴스 생성\napp = Celery(\n    'my_project',\n    broker='redis://localhost:6379/0',\n    backend='redis://localhost:6379/1',\n    include=['celery_app.tasks']\n)\n\n# Celery 설정\napp.conf.update(\n    result_expires=3600,  # 결과 유효 시간\n    task_serializer='json',\n    accept_content=['json'],\n    result_serializer='json',\n    timezone='Asia/Seoul',\n    enable_utc=True,\n)\n\n# 정기적 작업 스케줄 설정\napp.conf.beat_schedule = {\n    'check-every-30-seconds': {\n        'task': 'celery_app.tasks.check_status',\n        'schedule': 30.0,\n    },\n}\n```\n\n## 태스크 정의\n\n### 1. 기본 태스크\n\n```python\n# celery_app/tasks.py\nfrom celery import shared_task\nimport time\n\n@shared_task\ndef add(x, y):\n    return x + y\n\n@shared_task(bind=True)\ndef long_task(self, seconds):\n    for i in range(seconds):\n        time.sleep(1)\n        # 진행 상태 업데이트\n        self.update_state(\n            state='PROGRESS',\n            meta={'current': i, 'total': seconds}\n        )\n    return {'status': 'Task completed'}\n```\n\n### 2. 에러 처리와 재시도\n\n```python\nfrom celery import shared_task\nfrom celery.exceptions import MaxRetriesExceededError\n\n@shared_task(\n    bind=True,\n    max_retries=3,\n    default_retry_delay=5,\n    autoretry_for=(Exception,)\n)\ndef reliable_task(self, data):\n    try:\n        # 작업 수행\n        result = process_data(data)\n        return result\n    except Exception as exc:\n        try:\n            self.retry(exc=exc)\n        except MaxRetriesExceededError:\n            # 최대 재시도 횟수 초과\n            return {'status': 'failed', 'error': str(exc)}\n```\n\n## 태스크 실행 및 모니터링\n\n### 1. 태스크 호출\n\n```python\n# 동기적 호출\nresult = add.delay(4, 4)\nprint(result.get())  # 결과 대기\n\n# 비동기적 호출\ntask = long_task.apply_async(args=[10])\nprint(task.id)  # 태스크 ID 출력\n```\n\n### 2. 상태 확인\n\n```python\ndef check_task_status(task_id):\n    task = long_task.AsyncResult(task_id)\n    if task.state == 'PENDING':\n        return {\n            'state': task.state,\n            'status': 'Task is waiting'\n        }\n    elif task.state == 'PROGRESS':\n        return {\n            'state': task.state,\n            'status': task.info\n        }\n    else:\n        return {\n            'state': task.state,\n            'status': task.info\n        }\n```\n\n## 고급 기능\n\n### 1. 체인 태스크\n\n```python\nfrom celery import chain\n\n# 태스크 체인 정의\nresult = chain(\n    add.s(4, 4),\n    multiply.s(2)\n)()\n```\n\n### 2. 그룹 태스크\n\n```python\nfrom celery import group\n\n# 병렬 태스크 실행\nnumbers = range(100)\nresult = group(add.s(i, i) for i in numbers)()\n```\n\n### 3. 태스크 라우팅\n\n```python\n# celery_app/celery.py\napp.conf.task_routes = {\n    'celery_app.tasks.add': {'queue': 'math'},\n    'celery_app.tasks.process_image': {'queue': 'image'},\n}\n```\n\n### 4. 주기적 태스크\n\n```python\nfrom celery.schedules import crontab\n\napp.conf.beat_schedule = {\n    'daily-report': {\n        'task': 'celery_app.tasks.generate_report',\n        'schedule': crontab(hour=0, minute=0),\n    },\n}\n```\n\n## 실전 예제\n\n### 1. 이미지 처리 태스크\n\n```python\nfrom PIL import Image\nimport os\n\n@shared_task\ndef process_image(image_path, size):\n    try:\n        with Image.open(image_path) as img:\n            # 이미지 리사이즈\n            resized_img = img.resize(size)\n\n            # 저장 경로 생성\n            filename = os.path.basename(image_path)\n            new_path = f'processed_{filename}'\n\n            # 처리된 이미지 저장\n            resized_img.save(new_path)\n\n            return {\n                'status': 'success',\n                'path': new_path\n            }\n    except Exception as e:\n        return {\n            'status': 'error',\n            'message': str(e)\n        }\n```\n\n### 2. 이메일 발송 태스크\n\n```python\nfrom celery import shared_task\nfrom email.mime.text import MIMEText\nimport smtplib\n\n@shared_task(\n    rate_limit='10/m',  # 분당 최대 10개\n    retry_backoff=True\n)\ndef send_email(to_addr, subject, body):\n    try:\n        msg = MIMEText(body)\n        msg['Subject'] = subject\n        msg['From'] = 'sender@example.com'\n        msg['To'] = to_addr\n\n        with smtplib.SMTP('smtp.example.com', 587) as server:\n            server.starttls()\n            server.login('user', 'password')\n            server.send_message(msg)\n\n        return {'status': 'sent', 'to': to_addr}\n    except Exception as e:\n        return {'status': 'error', 'message': str(e)}\n```\n\n## Docker 환경 설정\n\n### 1. Dockerfile\n\n```dockerfile\nFROM python:3.9\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nCOPY . .\n\nCMD [\"celery\", \"-A\", \"celery_app\", \"worker\", \"--loglevel=info\"]\n```\n\n### 2. Docker Compose\n\n```yaml\nversion: '3'\n\nservices:\n  redis:\n    image: redis:latest\n    ports:\n      - '6379:6379'\n\n  celery_worker:\n    build: .\n    command: celery -A celery_app worker --loglevel=info\n    volumes:\n      - .:/app\n    depends_on:\n      - redis\n\n  celery_beat:\n    build: .\n    command: celery -A celery_app beat --loglevel=info\n    volumes:\n      - .:/app\n    depends_on:\n      - redis\n```\n\n## 모니터링 및 관리\n\n### 1. Flower 설정\n\n```bash\npip install flower\ncelery -A celery_app flower\n```\n\n### 2. 모니터링 엔드포인트\n\n```python\nfrom celery.task.control import inspect\n\ndef get_active_tasks():\n    i = inspect()\n    return {\n        'active': i.active(),\n        'scheduled': i.scheduled(),\n        'reserved': i.reserved()\n    }\n```\n\n## 성능 최적화\n\n1. **프리펫치 설정**\n\n```python\napp.conf.worker_prefetch_multiplier = 1\n```\n\n2. **작업자 풀 설정**\n\n```python\napp.conf.worker_pool = 'prefork'\napp.conf.worker_concurrency = 4\n```\n\n3. **결과 백엔드 최적화**\n\n```python\napp.conf.result_expires = 3600  # 1시간\napp.conf.task_ignore_result = True  # 결과 저장 비활성화\n```\n\n## 보안 고려사항\n\n1. **메시지 서명**\n\n```python\napp.conf.task_serializer = 'json'\napp.conf.accept_content = ['json']\napp.conf.task_protocol = 2\n```\n\n2. **SSL/TLS 설정**\n\n```python\napp.conf.broker_use_ssl = {\n    'keyfile': '/path/to/key.key',\n    'certfile': '/path/to/cert.cert',\n    'ca_certs': '/path/to/ca.pem',\n    'cert_reqs': ssl.CERT_REQUIRED\n}\n```\n\n## 트러블슈팅\n\n### 일반적인 문제 해결\n\n1. **작업자 연결 실패**\n\n```python\n# 브로커 연결 상태 확인\nfrom celery_app import app\napp.control.ping()\n```\n\n2. **메모리 누수**\n\n```python\n# 메모리 사용량 모니터링\nfrom memory_profiler import profile\n\n@profile\n@shared_task\ndef memory_intensive_task():\n    pass\n```\n\n3. **데드락 방지**\n\n```python\napp.conf.task_acks_late = True\napp.conf.task_reject_on_worker_lost = True\n```\n\n## 마치며\n\nCelery는 강력한 분산 태스크 처리 시스템이지만, 적절한 설정과 모니터링이 필요합니다. 실제 운영 환경에서는 성능, 안정성, 보안을 종합적으로 고려하여 구현해야 합니다.\n"},{"excerpt":"MongoDB Replica Set 구성 및 운영 개요 MongoDB Replica Set은 동일한 데이터를 가진 여러 MongoDB 인스턴스의 집합입니다. 이는 데이터의 고가용성과 장애 복구를 보장하는 핵심 기능입니다. Replica Set의 구조 기본 구성 요소 Primary: 쓰기 작업을 처리하는 주 노드 Secondary: 읽기 작업을 처리할 수 …","fields":{"slug":"/mongodb-replicaset/"},"frontmatter":{"date":"December 13, 2024","title":"MongoDB Replica Set 구성 및 운영","tags":["Database","MongoDB","ReplicaSet","HighAvailability"]},"rawMarkdownBody":"\n# MongoDB Replica Set 구성 및 운영\n\n## 개요\n\nMongoDB Replica Set은 동일한 데이터를 가진 여러 MongoDB 인스턴스의 집합입니다. 이는 데이터의 고가용성과 장애 복구를 보장하는 핵심 기능입니다.\n\n## Replica Set의 구조\n\n### 기본 구성 요소\n\n- **Primary**: 쓰기 작업을 처리하는 주 노드\n- **Secondary**: 읽기 작업을 처리할 수 있는 복제 노드\n- **Arbiter** (선택적): 투표만 참여하는 노드\n\n### 최소 구성\n\n- 3개의 데이터 노드 (1 Primary + 2 Secondary)\n- 2개의 데이터 노드 + 1개의 Arbiter\n\n## Docker Compose를 이용한 Replica Set 구성\n\n```yaml\nversion: '3.8'\n\nservices:\n  mongo1:\n    image: mongo:latest\n    container_name: mongo1\n    command: mongod --replSet myReplicaSet --bind_ip_all\n    ports:\n      - '27017:27017'\n    volumes:\n      - mongo1_data:/data/db\n    networks:\n      - mongo_network\n\n  mongo2:\n    image: mongo:latest\n    container_name: mongo2\n    command: mongod --replSet myReplicaSet --bind_ip_all\n    ports:\n      - '27018:27017'\n    volumes:\n      - mongo2_data:/data/db\n    networks:\n      - mongo_network\n\n  mongo3:\n    image: mongo:latest\n    container_name: mongo3\n    command: mongod --replSet myReplicaSet --bind_ip_all\n    ports:\n      - '27019:27017'\n    volumes:\n      - mongo3_data:/data/db\n    networks:\n      - mongo_network\n\nvolumes:\n  mongo1_data:\n  mongo2_data:\n  mongo3_data:\n\nnetworks:\n  mongo_network:\n    driver: bridge\n```\n\n## Replica Set 초기화\n\n### 1. Primary 노드 접속\n\n```bash\ndocker exec -it mongo1 mongosh\n```\n\n### 2. Replica Set 구성 초기화\n\n```javascript\nrs.initiate({\n  _id: 'myReplicaSet',\n  members: [\n    { _id: 0, host: 'mongo1:27017' },\n    { _id: 1, host: 'mongo2:27017' },\n    { _id: 2, host: 'mongo3:27017' },\n  ],\n});\n```\n\n### 3. Replica Set 상태 확인\n\n```javascript\nrs.status();\n```\n\n## Replica Set 운영\n\n### 읽기 기본 설정\n\n```javascript\n// 읽기 기본 설정 확인\ndb.getMongo().getReadPrefMode();\n\n// Secondary에서도 읽기 허용\ndb.getMongo().setReadPref('secondaryPreferred');\n```\n\n### 읽기 선호도 옵션\n\n- **primary**: 기본값, Primary에서만 읽기\n- **primaryPreferred**: Primary 우선, 불가능할 경우 Secondary\n- **secondary**: Secondary에서만 읽기\n- **secondaryPreferred**: Secondary 우선, 불가능할 경우 Primary\n- **nearest**: 네트워크 지연시간이 가장 낮은 멤버\n\n### 노드 관리 명령어\n\n```javascript\n// Replica Set 구성 확인\nrs.conf();\n\n// Secondary 노드 추가\nrs.add('mongodb4:27017');\n\n// Arbiter 노드 추가\nrs.addArb('mongodbarbiter:27017');\n\n// 노드 제거\nrs.remove('mongodb4:27017');\n\n// Primary 강제 변경\nrs.stepDown();\n```\n\n## 모니터링 및 유지보수\n\n### 복제 지연 모니터링\n\n```javascript\n// 복제 상태 확인\nrs.printReplicationInfo();\n\n// Secondary 복제 지연 확인\nrs.printSecondaryReplicationInfo();\n```\n\n### 노드 상태 모니터링\n\n```javascript\n// 전체 상태 확인\nrs.status();\n\n// 멤버별 상태 확인\ndb.serverStatus().repl;\n```\n\n## 장애 상황 처리\n\n### Primary 노드 장애\n\n1. 자동으로 새로운 Primary 선출\n2. 기존 Primary 복구 후 Secondary로 자동 전환\n\n```javascript\n// 수동으로 Primary 변경\nrs.stepDown(300); // 300초 동안 Primary 역할 포기\n```\n\n### Secondary 노드 장애\n\n1. 자동으로 복제 세트에서 제외\n2. 복구 후 자동으로 데이터 동기화\n\n```javascript\n// 수동으로 Secondary 재시작\ndb.adminCommand({ replSetMaintenance: 1 }); // 유지보수 모드 시작\ndb.adminCommand({ replSetMaintenance: 0 }); // 유지보수 모드 종료\n```\n\n## 운영 시 주의사항\n\n### 1. 네트워크 구성\n\n- 멤버 간 안정적인 네트워크 연결 필요\n- 방화벽 설정 확인\n- Hostname 해석 가능 여부 확인\n\n### 2. 디스크 관리\n\n- 충분한 디스크 공간 확보\n- 디스크 I/O 모니터링\n- 정기적인 백업 수행\n\n### 3. 보안 설정\n\n```javascript\n// 복제 세트 인증 설정\nsecurity:\n  keyFile: /path/to/keyfile\n  authorization: enabled\n```\n\n### 4. 성능 최적화\n\n- Write Concern 설정\n- Read Preference 적절히 구성\n- 인덱스 동기화 상태 모니터링\n\n## 모범 사례\n\n1. **구성 크기**\n\n   - 홀수 개의 노드로 구성\n   - 최소 3개의 데이터 노드 권장\n\n2. **지리적 분산**\n\n   - 가용성 향상을 위해 다른 데이터센터에 분산\n   - 네트워크 지연시간 고려\n\n3. **모니터링**\n\n   - 복제 지연 모니터링\n   - 디스크 사용량 모니터링\n   - 네트워크 상태 모니터링\n\n4. **백업**\n   - Secondary 노드에서 백업 수행\n   - 정기적인 백업 및 복구 테스트\n\n## 문제 해결\n\n### 1. 복제 지연 발생 시\n\n```javascript\n// 복제 지연 확인\nrs.printSecondaryReplicationInfo();\n\n// 원인 분석\ndb.currentOp();\n```\n\n### 2. 선출 문제 발생 시\n\n```javascript\n// 선출 설정 확인\nrs.config();\n\n// 강제 선출\nrs.reconfig(cfg, { force: true });\n```\n\n### 3. 데이터 동기화 문제\n\n```javascript\n// 초기 동기화 강제 실행\nrs.resync();\n\n// 동기화 상태 확인\nrs.printReplicationInfo();\n```\n\n## 마치며\n\nMongoDB Replica Set은 고가용성과 데이터 안정성을 보장하는 핵심 기능입니다. 적절한 구성과 모니터링, 그리고 문제 발생 시 신속한 대응이 중요합니다. 다음 글에서는 Sharding과 Replica Set을 함께 사용하는 방법에 대해 알아보도록 하겠습니다.\n"},{"excerpt":"Tauri 소개 및 사용 가이드 개요 Tauri는 HTML, CSS, JavaScript와 같은 웹 기술을 사용해 경량 데스크톱 애플리케이션을 개발할 수 있는 프레임워크입니다. Electron과 비슷한 목적을 가지지만, 더 작은 애플리케이션 크기와 향상된 보안을 제공합니다. 주요 특징 가벼운 애플리케이션 크기: Tauri는 시스템의 기본 WebView를 …","fields":{"slug":"/Tauri/"},"frontmatter":{"date":"December 09, 2024","title":"Tauri 소개 및 사용 가이드","tags":["Tauri","Desktop Development","Rust"]},"rawMarkdownBody":"\n# Tauri 소개 및 사용 가이드\n\n## 개요\n\nTauri는 HTML, CSS, JavaScript와 같은 웹 기술을 사용해 **경량 데스크톱 애플리케이션**을 개발할 수 있는 프레임워크입니다. Electron과 비슷한 목적을 가지지만, 더 작은 애플리케이션 크기와 향상된 보안을 제공합니다.\n\n---\n\n## 주요 특징\n\n1. **가벼운 애플리케이션 크기**:\n\n   - Tauri는 시스템의 기본 WebView를 사용하여, **3~5MB**의 작은 애플리케이션 크기를 유지합니다.\n\n2. **보안성**:\n\n   - 파일 시스템 접근, 네트워크 요청 등을 세밀하게 제어하는 **강력한 보안 모델**을 제공합니다.\n\n3. **다중 플랫폼 지원**:\n\n   - Windows, macOS, Linux를 동일한 코드베이스로 지원.\n\n4. **Rust 기반 백엔드**:\n\n   - Rust로 작성된 백엔드를 통해 **성능과 안정성**을 극대화합니다.\n\n5. **WebView 활용**:\n   - 각 플랫폼에 내장된 WebView를 사용:\n     - Windows: WebView2 (Edge 기반)\n     - macOS: WebKit\n     - Linux: GTK WebKit\n\n---\n\n## Tauri의 구조\n\n- **Frontend**:\n  - React, Vue, Svelte, Angular 등 웹 프레임워크로 개발 가능.\n  - HTML, CSS, JavaScript 기반.\n- **Backend**:\n  - Rust로 작성되며, 시스템 리소스와 직접 상호작용.\n\n---\n\n## Tauri와 Electron의 비교\n\n| 특징          | Tauri                    | Electron                 |\n| ------------- | ------------------------ | ------------------------ |\n| 런타임 크기   | 3~5MB                    | 50~200MB                 |\n| 브라우저 엔진 | 시스템 내장 WebView 사용 | 크롬(V8 엔진) 포함       |\n| 성능          | 더 가벼움                | 더 무거움                |\n| 언어 지원     | Rust + JavaScript        | JavaScript               |\n| 보안          | 강력한 보안 모델 제공    | 제한적 보안 기능         |\n| 개발 생산성   | 초기 학습 곡선 존재      | 친숙한 JavaScript 생태계 |\n\n---\n\n## Tauri의 사용 사례\n\n1. **경량 데스크톱 애플리케이션 개발**:\n   - 메모리 사용량과 디스크 크기가 중요한 도구형 애플리케이션.\n2. **보안이 중요한 앱**:\n   - 암호화 도구, 파일 관리 도구.\n3. **플랫폼 간 애플리케이션**:\n   - Windows, macOS, Linux를 동시에 지원하는 앱.\n\n---\n\n## 설치 및 시작하기\n\n### 1. Rust 설치\n\nRust 개발 환경을 설치합니다:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n### 2. Tauri CLI 설치\n\nTauri CLI를 글로벌로 설치합니다:\n\n```bash\nnpm install -g @tauri-apps/cli\n```\n\n### 3. 새 프로젝트 생성\n\nTauri 프로젝트를 생성합니다:\n\n```bash\nnpx create-tauri-app my-tauri-app\ncd my-tauri-app\n```\n\n### 4. 애플리케이션 실행\n\n개발 서버를 실행합니다:\n\n```bash\nnpm run tauri dev\n```\n\n---\n\n## 장점 및 단점\n\n### 장점\n\n- **작은 애플리케이션 크기**: 3~5MB로 매우 경량.\n- **다중 플랫폼 지원**: 한 번의 개발로 Windows, macOS, Linux 지원.\n- **보안**: 강력한 보안 모델 제공.\n\n### 단점\n\n- **Rust 학습 필요**: Rust 백엔드 작업을 위해 새로운 언어를 배워야 할 수 있음.\n- **초기 설정 복잡성**: Electron보다 설정이 복잡할 수 있음.\n\n---\n\n**Q1**\n\nTauri와 Electron 중 어느 환경이 특정 프로젝트에 더 적합한지 판단하려면 어떤 요소를 고려해야 할까?\n\n**Q2**\n\nTauri 프로젝트에서 Rust와 JavaScript 간의 상호작용을 최적화하는 방법은 무엇인가?\n\n**Q3**\n\nTauri 애플리케이션의 보안을 강화하기 위해 활용할 수 있는 주요 기능은 무엇인가?\n"},{"excerpt":"MicroK8s 사용 가이드 MicroK8s란? MicroK8s는 가볍고 빠른 완전한 기능을 갖춘 단일 패키지 Kubernetes입니다. 개발자의 워크스테이션부터 IoT 기기, CI/CD 환경까지 다양한 환경에서 사용할 수 있도록 설계되었습니다. 주요 특징 간편한 설치와 관리 단일 명령어로 설치 가능 자동 업데이트 지원 최소한의 설정으로 즉시 사용 가능 …","fields":{"slug":"/microk8s/"},"frontmatter":{"date":"December 09, 2024","title":"MicroK8s 사용 가이드","tags":["Kubernetes","MicroK8s","Container","DevOps"]},"rawMarkdownBody":"\n# MicroK8s 사용 가이드\n\n## MicroK8s란?\n\nMicroK8s는 가볍고 빠른 완전한 기능을 갖춘 단일 패키지 Kubernetes입니다. 개발자의 워크스테이션부터 IoT 기기, CI/CD 환경까지 다양한 환경에서 사용할 수 있도록 설계되었습니다.\n\n## 주요 특징\n\n1. **간편한 설치와 관리**\n\n   - 단일 명령어로 설치 가능\n   - 자동 업데이트 지원\n   - 최소한의 설정으로 즉시 사용 가능\n\n2. **가벼운 리소스 사용**\n\n   - 최소 시스템 요구사항이 낮음\n   - 메모리 사용량 최적화\n   - 빠른 시작 시간\n\n3. **완전한 Kubernetes 호환성**\n   - 표준 Kubernetes API 지원\n   - 모든 Kubernetes 워크로드 실행 가능\n   - 기존 Kubernetes YAML 파일 사용 가능\n\n## 설치 방법\n\n### Ubuntu에서 설치\n\n```bash\nsudo snap install microk8s --classic\n```\n\n### Windows에서 설치\n\n1. Windows Subsystem for Linux (WSL) 설치\n2. Ubuntu WSL 내에서 MicroK8s 설치\n\n```bash\nsudo snap install microk8s --classic\n```\n\n### macOS에서 설치\n\n```bash\nbrew install ubuntu/microk8s/microk8s\n```\n\n## 기본 사용법\n\n### 1. 상태 확인\n\n```bash\nmicrok8s status\n```\n\n### 2. 애드온 활성화\n\n```bash\n# DNS 활성화\nmicrok8s enable dns\n\n# 대시보드 활성화\nmicrok8s enable dashboard\n\n# 저장소 활성화\nmicrok8s enable storage\n```\n\n### 3. kubectl 사용\n\n```bash\n# Pod 목록 조회\nmicrok8s kubectl get pods\n\n# 서비스 목록 조회\nmicrok8s kubectl get services\n\n# 디플로이먼트 생성\nmicrok8s kubectl create deployment nginx --image=nginx\n```\n\n## 주요 애드온 소개\n\n### 1. Dashboard\n\n- Kubernetes 클러스터를 웹 인터페이스로 관리\n- 리소스 모니터링 및 관리 기능 제공\n\n```bash\nmicrok8s enable dashboard\n```\n\n### 2. DNS\n\n- 클러스터 내부 도메인 이름 해결\n- 서비스 디스커버리 지원\n\n```bash\nmicrok8s enable dns\n```\n\n### 3. Registry\n\n- 프라이빗 컨테이너 레지스트리\n- 로컬 이미지 저장 및 관리\n\n```bash\nmicrok8s enable registry\n```\n\n## 문제 해결 가이드\n\n### 1. 일반적인 문제\n\n- **클러스터 상태 검사**\n\n```bash\nmicrok8s inspect\n```\n\n- **서비스 재시작**\n\n```bash\nmicrok8s stop\nmicrok8s start\n```\n\n### 2. 로그 확인\n\n```bash\nmicrok8s kubectl logs <pod-name>\n```\n\n## 보안 설정\n\n### 1. RBAC 활성화\n\n```bash\nmicrok8s enable rbac\n```\n\n### 2. 인증서 관리\n\n```bash\nmicrok8s refresh-certs\n```\n\n## 성능 최적화 팁\n\n1. **리소스 제한 설정**\n\n   - Pod에 적절한 리소스 제한 설정\n   - 노드 리소스 모니터링\n\n2. **캐시 설정**\n   - 이미지 풀링 정책 최적화\n   - 로컬 레지스트리 활용\n\n## 프로덕션 환경 준비사항\n\n1. **고가용성 설정**\n\n   - 다중 노드 구성\n   - 백업 전략 수립\n\n2. **모니터링 설정**\n   - Prometheus 활성화\n   - Grafana 대시보드 구성\n\n## 참고 자료\n\n- [공식 MicroK8s 문서](https://microk8s.io/docs)\n- [Kubernetes 공식 문서](https://kubernetes.io/docs)\n- [MicroK8s GitHub](https://github.com/canonical/microk8s)\n\n## 마치며\n\nMicroK8s는 Kubernetes를 시작하는 가장 쉬운 방법 중 하나입니다. 이 가이드를 통해 기본적인 설정과 사용법을 익히고, 필요에 따라 심화 학습을 진행하시기 바랍니다.\n"},{"excerpt":"Docker Hub 서버 구축 문서 1. Docker Hub 서버 구축 개요 Docker Hub는 컨테이너 이미지를 저장하고 관리할 수 있는 레지스트리 서비스입니다. Docker Hub와 유사한 기능을 제공하는 자체 Docker Registry 서버를 구축하면 조직 내에서 이미지 관리를 중앙화하고 보안을 강화할 수 있습니다. 이 문서에서는 Docker의 …","fields":{"slug":"/Docker_Hub_Registry/"},"frontmatter":{"date":"December 09, 2024","title":"Docker Hub 서버 구축 가이드","tags":["Docker","DevOps","Registry","Automation"]},"rawMarkdownBody":"\n# Docker Hub 서버 구축 문서\n\n## 1. Docker Hub 서버 구축 개요\n\nDocker Hub는 컨테이너 이미지를 저장하고 관리할 수 있는 레지스트리 서비스입니다. Docker Hub와 유사한 기능을 제공하는 자체 Docker Registry 서버를 구축하면 조직 내에서 이미지 관리를 중앙화하고 보안을 강화할 수 있습니다.\n\n이 문서에서는 Docker의 오픈소스 레지스트리 `docker-registry`를 사용하여 Docker Hub와 유사한 기능을 제공하는 사설 Docker Registry를 구축하는 과정을 안내합니다.\n\n## 2. 사전 준비\n\n### 필수 조건\n\n- **서버 환경**: Linux 서버 (Ubuntu, CentOS 등)\n- **Docker**: 최신 버전 설치\n- **도메인**: 레지스트리 서버 접근용 도메인 (옵션)\n- **SSL 인증서**: HTTPS 통신을 위한 인증서 (Let's Encrypt 또는 상용 인증서 사용 가능)\n\n## 3. Docker Registry 설치\n\n### Step 1: Docker 설치\n\n```bash\nsudo apt update\nsudo apt install -y docker.io\nsudo systemctl start docker\nsudo systemctl enable docker\n```\n\n### Step 2: Docker Registry 컨테이너 실행\n\n```bash\ndocker run -d \\\n  --name registry \\\n  -p 5000:5000 \\\n  -v /opt/registry/data:/var/lib/registry \\\n  registry:2\n```\n\n- `-p 5000:5000`: 호스트의 5000번 포트를 레지스트리 컨테이너에 매핑\n- `/opt/registry/data`: 이미지 데이터를 저장할 디렉토리\n- `registry:2`: Docker의 공식 Registry 이미지\n\n## 4. HTTPS 및 인증 설정\n\n### Step 1: SSL 인증서 준비\n\n1. Let's Encrypt로 SSL 인증서 발급:\n   ```bash\n   sudo apt install -y certbot\n   sudo certbot certonly --standalone -d <your-domain>\n   ```\n2. 인증서 위치:\n   - 인증서 파일: `/etc/letsencrypt/live/<your-domain>/fullchain.pem`\n   - 키 파일: `/etc/letsencrypt/live/<your-domain>/privkey.pem`\n\n### Step 2: Nginx 설치 및 설정\n\nNginx를 사용하여 HTTPS를 설정합니다.\n\n1. Nginx 설치:\n   ```bash\n   sudo apt install -y nginx\n   ```\n2. Nginx 설정 파일 생성:\n\n   ```bash\n   sudo nano /etc/nginx/sites-available/registry\n   ```\n\n   아래 내용을 추가:\n\n   ```nginx\n   server {\n       listen 443 ssl;\n       server_name <your-domain>;\n\n       ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;\n       ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;\n\n       location / {\n           proxy_pass http://localhost:5000;\n           proxy_set_header Host $host;\n           proxy_set_header X-Real-IP $remote_addr;\n           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n           proxy_set_header X-Forwarded-Proto $scheme;\n       }\n   }\n\n   server {\n       listen 80;\n       server_name <your-domain>;\n\n       location / {\n           return 301 https://$host$request_uri;\n       }\n   }\n   ```\n\n3. Nginx 설정 활성화:\n   ```bash\n   sudo ln -s /etc/nginx/sites-available/registry /etc/nginx/sites-enabled/\n   sudo systemctl restart nginx\n   ```\n\n## 5. 사용자 인증 추가 (옵션)\n\n### Step 1: 사용자 인증 파일 생성\n\n```bash\nsudo apt install apache2-utils\nsudo htpasswd -c /opt/registry/auth/htpasswd <username>\n```\n\n### Step 2: Registry 컨테이너 실행 시 인증 활성화\n\nDocker Registry 컨테이너를 다시 실행합니다:\n\n```bash\ndocker run -d \\\n  --name registry \\\n  -p 5000:5000 \\\n  -v /opt/registry/data:/var/lib/registry \\\n  -v /opt/registry/auth:/auth \\\n  -e \"REGISTRY_AUTH=htpasswd\" \\\n  -e \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\\n  -e \"REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd\" \\\n  registry:2\n```\n\n## 6. 클라이언트 설정\n\n### Step 1: Docker 클라이언트 인증\n\n사용자 인증 정보를 Docker에 저장:\n\n```bash\ndocker login <your-domain>\n```\n\n### Step 2: Docker 이미지 푸시\n\n1. 태그 지정:\n   ```bash\n   docker tag <local-image> <your-domain>/<repository>:<tag>\n   ```\n2. 이미지 푸시:\n   ```bash\n   docker push <your-domain>/<repository>:<tag>\n   ```\n\n## 7. 모니터링 및 로그 관리\n\n### Step 1: 로그 확인\n\n```bash\ndocker logs registry\n```\n\n### Step 2: Log Rotation 설정\n\nDocker 로그가 과도하게 커지지 않도록 설정:\n\n```bash\ndocker run -d \\\n  --name registry \\\n  --log-opt max-size=10m \\\n  --log-opt max-file=3 \\\n  -p 5000:5000 \\\n  -v /opt/registry/data:/var/lib/registry \\\n  registry:2\n```\n\n## 8. 참고 자료\n\n- Docker Registry 공식 문서: [Docker Registry Docs](https://docs.docker.com/registry/)\n- Nginx 설정 가이드: [Nginx Docs](https://nginx.org/en/docs/)\n"},{"excerpt":"Playwright 기본 사용 가이드 개요 Playwright는 Microsoft에서 개발한 웹 애플리케이션 테스트 자동화 도구로, Chromium, Firefox, WebKit 등 다양한 브라우저에서 테스트를 지원한다. 강력한 API와 병렬 실행 기능을 제공하여 효율적인 테스트 환경을 구축할 수 있다. 공식 문서: Playwright 공식 문서 설치 방…","fields":{"slug":"/Playwright/"},"frontmatter":{"date":"December 09, 2024","title":"Playwright 시작하기","tags":["Playwright","Automation","Testing"]},"rawMarkdownBody":"\n# Playwright 기본 사용 가이드\n\n## 개요\n\nPlaywright는 Microsoft에서 개발한 웹 애플리케이션 테스트 자동화 도구로, Chromium, Firefox, WebKit 등 다양한 브라우저에서 테스트를 지원한다. 강력한 API와 병렬 실행 기능을 제공하여 효율적인 테스트 환경을 구축할 수 있다. 공식 문서: [Playwright 공식 문서](https://playwright.dev)\n\n## 설치 방법\n\n### Node.js 설치\n\nPlaywright는 Node.js 기반이므로, 먼저 Node.js를 설치해야 한다. 최신 LTS 버전을 설치하는 것이 권장된다: [Node.js 다운로드](https://nodejs.org)\n\n### Playwright 설치\n\n1. 프로젝트 폴더를 생성한 후 npm 초기화:\n   ```bash\n   mkdir playwright-project\n   cd playwright-project\n   npm init -y\n   ```\n2. Playwright 설치:\n   ```bash\n   npm install playwright\n   ```\n3. Playwright 환경 설치 (필요한 브라우저를 포함):\n   ```bash\n   npx playwright install\n   ```\n\n## 기본 사용법\n\n### 첫 번째 스크립트 작성\n\n`example.spec.js` 파일 생성:\n\n```javascript\nconst { test, expect } = require('@playwright/test');\n\ntest('Example Test', async ({ page }) => {\n  await page.goto('https://example.com');\n  const title = await page.title();\n  expect(title).toBe('Example Domain');\n});\n```\n\n### 테스트 실행\n\nPlaywright 테스트 실행:\n\n```bash\nnpx playwright test\n```\n\n### 브라우저 열고 실행\n\n테스트를 브라우저에서 디버깅하려면:\n\n```bash\nnpx playwright test --headed\n```\n\n## 주요 기능\n\n### 페이지 스크린샷\n\n```javascript\nawait page.screenshot({ path: 'screenshot.png' });\n```\n\n### 엘리먼트 선택 및 동작\n\n```javascript\nawait page.click('text=Get Started');\nawait page.fill('#username', 'myUsername');\nawait page.press('#password', 'Enter');\n```\n\n### 네트워크 요청 가로채기\n\n```javascript\nawait page.route('**/*', (route) => {\n  console.log(route.request().url());\n  route.continue();\n});\n```\n\n### 병렬 테스트 실행\n\nPlaywright는 병렬 실행을 기본적으로 지원한다. 설정 파일에서 워커 수를 지정하여 병렬성을 조정할 수 있다:\n\n```json\n// playwright.config.js\nmodule.exports = {\n  workers: 4\n};\n```\n\n## 디버깅\n\n1. `playwright.config.js`에 `trace` 설정 추가:\n   ```javascript\n   module.exports = {\n     use: {\n       trace: 'on-first-retry',\n     },\n   };\n   ```\n2. 실행 후 `.zip` 파일로 저장된 Trace를 Playwright Trace Viewer로 분석:\n   ```bash\n   npx playwright show-trace trace.zip\n   ```\n\n## 업데이트 및 제거\n\n### 업데이트\n\n```bash\nnpm update playwright\n```\n\n### 제거\n\n```bash\nnpm uninstall playwright\n```\n\n---\n"},{"excerpt":"Go 언어로 빌드된 바이너리 크기 최적화 요약 기본 상태 Go 언어로 \"Hello World\" 프로그램을 빌드하면 기본적으로 약 2MB 정도의 바이너리가 생성됩니다. 이는 Go 런타임, 가비지 컬렉터, 그리고 다양한 표준 라이브러리가 포함되어 있기 때문입니다. 최적화 방법 1. 컴파일 옵션 사용 : 디버그 심볼 테이블 제거 : DWARF 디버그 정보 제거…","fields":{"slug":"/go-binary-optimization/"},"frontmatter":{"date":"December 09, 2024","title":"Go 바이너리 크기 최적화","tags":["Go","Optimization","Programming"]},"rawMarkdownBody":"\n# Go 언어로 빌드된 바이너리 크기 최적화\n\n## 요약\n\n### 기본 상태\n\nGo 언어로 \"Hello World\" 프로그램을 빌드하면 기본적으로 약 2MB 정도의 바이너리가 생성됩니다. 이는 Go 런타임, 가비지 컬렉터, 그리고 다양한 표준 라이브러리가 포함되어 있기 때문입니다.\n\n## 최적화 방법\n\n### 1. 컴파일 옵션 사용\n\n```bash\n# 기본 빌드\ngo build -o app\n\n# 크기 최적화 빌드\ngo build -ldflags=\"-s -w\" -o app_optimized\n```\n\n- `-s`: 디버그 심볼 테이블 제거\n- `-w`: DWARF 디버그 정보 제거\n\n### 2. UPX 압축 사용\n\n```bash\n# UPX 설치\nbrew install upx  # macOS\nsudo apt install upx  # Ubuntu\n\n# 바이너리 압축\nupx --best app_optimized\n```\n\n### 3. 불필요한 패키지 제거\n\n```go\n// main.go\nimport (\n    \"fmt\"\n    // 불필요한 패키지 제거\n    // \"net/http\"\n    // \"encoding/json\"\n)\n```\n\n### 4. 최적화된 컴파일러 사용\n\n```bash\n# Go 1.18 이상에서 사용 가능\ngo build -gcflags=\"-l -B\" -o app\n```\n\n## 실제 예제\n\n### 1. 기본 빌드 크기\n\n```bash\ngo build -o app\nls -lh app\n# -rwxr-xr-x  1 user  staff   2.1M Dec  9 10:00 app\n```\n\n### 2. 최적화 후 크기\n\n```bash\ngo build -ldflags=\"-s -w\" -o app_optimized\nupx --best app_optimized\nls -lh app_optimized\n# -rwxr-xr-x  1 user  staff   1.2M Dec  9 10:01 app_optimized\n```\n\n## 주의사항\n\n1. 디버깅 어려움\n\n   - 최적화된 바이너리는 디버깅이 어려울 수 있음\n   - 개발 환경에서는 최적화 옵션 사용을 피할 것\n\n2. 성능 영향\n\n   - 일부 최적화는 실행 속도에 영향을 줄 수 있음\n   - 프로파일링을 통한 성능 검증 필요\n\n3. 호환성 문제\n   - 특정 플랫폼에서 최적화된 바이너리가 실행되지 않을 수 있음\n   - 테스트 환경에서 충분한 검증 필요\n\n## 추가 최적화 기법\n\n### 1. TinyGo 사용\n\n```bash\n# TinyGo 설치\nbrew install tinygo  # macOS\nsudo apt install tinygo  # Ubuntu\n\n# TinyGo로 빌드\ntinygo build -o app_tiny\n```\n\n### 2. CGO 비활성화\n\n```bash\nCGO_ENABLED=0 go build -o app\n```\n\n### 3. 특정 아키텍처 최적화\n\n```bash\nGOARCH=amd64 GOOS=linux go build -o app_linux\n```\n\n## 참고 자료\n\n- [Go 컴파일러 최적화 가이드](https://golang.org/cmd/compile/)\n- [UPX 공식 문서](https://upx.github.io/)\n- [TinyGo 공식 문서](https://tinygo.org/)\n"},{"excerpt":"AutoGen 초보자 가이드 AutoGen이란? AutoGen은 Microsoft에서 개발한 차세대 AI 애플리케이션 개발 프레임워크입니다. 여러 AI 에이전트들이 서로 대화하고 협력하여 복잡한 작업을 수행할 수 있게 해주는 도구입니다. 왜 AutoGen을 사용해야 할까요? 효율적인 작업 처리 여러 AI가 협력하여 복잡한 문제 해결 자동화된 코드 실행과 …","fields":{"slug":"/autogen-guide/"},"frontmatter":{"date":"December 09, 2024","title":"AutoGen 초보자 가이드","tags":["AutoGen","AI","Python","LLM"]},"rawMarkdownBody":"\n# AutoGen 초보자 가이드\n\n## AutoGen이란?\n\nAutoGen은 Microsoft에서 개발한 차세대 AI 애플리케이션 개발 프레임워크입니다. 여러 AI 에이전트들이 서로 대화하고 협력하여 복잡한 작업을 수행할 수 있게 해주는 도구입니다.\n\n## 왜 AutoGen을 사용해야 할까요?\n\n1. **효율적인 작업 처리**\n\n   - 여러 AI가 협력하여 복잡한 문제 해결\n   - 자동화된 코드 실행과 디버깅\n   - 사용자 개입 최소화\n\n2. **유연한 개발 환경**\n   - 다양한 AI 모델 지원 (GPT-4, Claude 등)\n   - 커스텀 에이전트 생성 가능\n   - Python 기반의 친숙한 환경\n\n## 설치 방법\n\n### 기본 설치\n\n```bash\npip install pyautogen\n```\n\n### 전체 기능 설치\n\n```bash\npip install \"pyautogen[all]\"\n```\n\n## 기본 개념\n\n### 1. 에이전트(Agent)\n\n- AI 대화 참여자\n- 각각 특정 역할과 능력을 가짐\n- 예: 코더, 리뷰어, 제품 매니저 등\n\n### 2. 대화(Conversation)\n\n- 에이전트들 간의 메시지 교환\n- 작업 목표를 달성하기 위한 협력 과정\n\n### 3. 실행 환경(Execution Environment)\n\n- 코드 실행을 위한 안전한 환경\n- 결과를 대화에 반영\n\n## 기본 사용법\n\n### 1. 간단한 대화 설정\n\n```python\nfrom autogen import AssistantAgent, UserProxyAgent\n\n# 어시스턴트 에이전트 생성\nassistant = AssistantAgent(name=\"assistant\")\n\n# 사용자 프록시 에이전트 생성\nuser_proxy = UserProxyAgent(name=\"user_proxy\")\n\n# 대화 시작\nuser_proxy.initiate_chat(\n    assistant,\n    message=\"간단한 파이썬 계산기를 만들어주세요.\"\n)\n```\n\n### 2. 다중 에이전트 설정\n\n```python\n# 코더 에이전트\ncoder = AssistantAgent(\n    name=\"coder\",\n    system_message=\"당신은 Python 전문가입니다.\"\n)\n\n# 리뷰어 에이전트\nreviewer = AssistantAgent(\n    name=\"reviewer\",\n    system_message=\"당신은 코드 리뷰 전문가입니다.\"\n)\n\n# 작업 관리자 에이전트\nmanager = UserProxyAgent(name=\"manager\")\n```\n\n## 주요 기능\n\n### 1. 코드 실행\n\n```python\n# 코드 실행이 가능한 에이전트 생성\nuser_proxy = UserProxyAgent(\n    name=\"user_proxy\",\n    code_execution_config={\"work_dir\": \"coding\"}\n)\n```\n\n### 2. 대화 관리\n\n```python\n# 대화 종료 조건 설정\nuser_proxy.initiate_chat(\n    assistant,\n    message=\"작업 시작\",\n    max_turns=10\n)\n```\n\n## 실전 예제\n\n### 1. 간단한 데이터 분석\n\n```python\nfrom autogen import AssistantAgent, UserProxyAgent\n\n# 데이터 분석가 에이전트 생성\nanalyst = AssistantAgent(\n    name=\"analyst\",\n    system_message=\"데이터 분석 전문가입니다.\"\n)\n\n# 사용자 프록시 생성\nuser = UserProxyAgent(\n    name=\"user\",\n    code_execution_config={\"work_dir\": \"analysis\"}\n)\n\n# 분석 작업 시작\nuser.initiate_chat(\n    analyst,\n    message=\"sales_data.csv 파일을 분석해주세요.\"\n)\n```\n\n## 문제 해결 가이드\n\n### 1. 일반적인 문제\n\n- **에이전트 응답 없음**\n\n  - 타임아웃 설정 확인\n  - 모델 API 키 확인\n\n- **코드 실행 오류**\n  - 실행 환경 설정 확인\n  - 필요한 라이브러리 설치\n\n### 2. 성능 최적화\n\n- 적절한 모델 선택\n- 대화 턴 수 제한\n- 메모리 관리\n\n## 모범 사례\n\n1. **에이전트 설계**\n\n   - 명확한 역할 정의\n   - 적절한 시스템 메시지 설정\n   - 필요한 도구만 활성화\n\n2. **대화 관리**\n\n   - 명확한 지시사항 제공\n   - 적절한 종료 조건 설정\n   - 오류 처리 구현\n\n3. **코드 실행**\n   - 안전한 실행 환경 구성\n   - 결과 검증 절차 구현\n   - 리소스 사용 모니터링\n\n## 참고 자료\n\n- [AutoGen 공식 문서](https://microsoft.github.io/autogen/)\n- [GitHub 저장소](https://github.com/microsoft/autogen)\n- [예제 모음](https://microsoft.github.io/autogen/docs/Examples)\n\n## 마치며\n\nAutoGen은 AI 애플리케이션 개발을 위한 강력한 도구입니다. 이 가이드를 통해 기본적인 사용법을 익히고, 점차 고급 기능들을 탐험해보세요. 실제 프로젝트에 적용하면서 더 많은 경험을 쌓을 수 있습니다.\n"},{"excerpt":"Playwright Python 상세 가이드 목차 소개 설치 기본 사용법 브라우저와 컨텍스트 페이지 조작 요소 선택 및 조작 이벤트 처리 네트워크 요청 처리 스크린샷 및 비디오 캡처 테스트 자동화 고급 기능 문제 해결 및 팁 1. 소개 Playwright는 Microsoft에서 개발한 강력한 웹 자동화 라이브러리입니다. 이 가이드에서는 Playwright…","fields":{"slug":"/playwright-python/"},"frontmatter":{"date":"December 09, 2024","title":"Playwright Python 상세 가이드","tags":["Playwright","Python","Web Automation","Testing"]},"rawMarkdownBody":"\n# Playwright Python 상세 가이드\n\n## 목차\n\n1. [소개](#1-소개)\n2. [설치](#2-설치)\n3. [기본 사용법](#3-기본-사용법)\n4. [브라우저와 컨텍스트](#4-브라우저와-컨텍스트)\n5. [페이지 조작](#5-페이지-조작)\n6. [요소 선택 및 조작](#6-요소-선택-및-조작)\n7. [이벤트 처리](#7-이벤트-처리)\n8. [네트워크 요청 처리](#8-네트워크-요청-처리)\n9. [스크린샷 및 비디오 캡처](#9-스크린샷-및-비디오-캡처)\n10. [테스트 자동화](#10-테스트-자동화)\n11. [고급 기능](#11-고급-기능)\n12. [문제 해결 및 팁](#12-문제-해결-및-팁)\n\n## 1. 소개\n\nPlaywright는 Microsoft에서 개발한 강력한 웹 자동화 라이브러리입니다. 이 가이드에서는 Playwright의 Python 버전 사용법을 상세히 설명합니다.\n\n## 2. 설치\n\nPlaywright를 설치하려면 다음 명령을 실행합니다:\n\n```bash\npip install playwright\nplaywright install\n```\n\n`playwright install` 명령은 필요한 브라우저 바이너리를 자동으로 다운로드합니다.\n\n## 3. 기본 사용법\n\n기본적인 Playwright 스크립트는 다음과 같습니다:\n\n```python\nfrom playwright.sync_api import sync_playwright\n\ndef run(playwright):\n    browser = playwright.chromium.launch()\n    page = browser.new_page()\n    page.goto(\"https://www.example.com\")\n    print(page.title())\n    browser.close()\n\nwith sync_playwright() as playwright:\n    run(playwright)\n```\n\n이 스크립트는 Chromium 브라우저를 실행하고, 예시 웹사이트를 방문한 후, 페이지 제목을 출력합니다.\n\n## 4. 브라우저와 컨텍스트\n\n### 브라우저 실행 옵션\n\n```python\nbrowser = playwright.chromium.launch(\n    headless=False,  # GUI 모드로 실행\n    slow_mo=50  # 각 작업 사이에 50ms 지연\n)\n```\n\n### 브라우저 컨텍스트 사용\n\n```python\ncontext = browser.new_context(\n    viewport={'width': 1280, 'height': 720},\n    user_agent='My Custom User Agent'\n)\npage = context.new_page()\n```\n\n## 5. 페이지 조작\n\n### 페이지 이동 및 대기\n\n```python\npage.goto(\"https://www.example.com\")\npage.wait_for_load_state(\"networkidle\")\n```\n\n### 페이지 상호작용\n\n```python\npage.click(\"button#submit\")\npage.fill(\"input#search\", \"Playwright\")\npage.press(\"input#search\", \"Enter\")\n```\n\n## 6. 요소 선택 및 조작\n\n### 요소 선택\n\n```python\nelement = page.query_selector(\"div.class\")\nelements = page.query_selector_all(\"li\")\n```\n\n### 요소 조작\n\n```python\nelement.click()\nelement.fill(\"Hello, Playwright!\")\nelement.check()  # 체크박스나 라디오 버튼 선택\n```\n\n## 7. 이벤트 처리\n\n```python\ndef handle_dialog(dialog):\n    print(dialog.message)\n    dialog.accept()\n\npage.on(\"dialog\", handle_dialog)\n```\n\n## 8. 네트워크 요청 처리\n\n### 요청 인터셉트\n\n```python\ndef handle_request(route):\n    if \".png\" in route.request.url:\n        route.abort()\n    else:\n        route.continue_()\n\npage.route(\"**/*\", handle_request)\n```\n\n### 응답 대기\n\n```python\nwith page.expect_response(\"https://api.example.com/data\") as response_info:\n    page.click(\"button#fetch-data\")\nresponse = response_info.value\n```\n\n## 9. 스크린샷 및 비디오 캡처\n\n### 스크린샷 촬영\n\n```python\npage.screenshot(path=\"screenshot.png\", full_page=True)\n```\n\n### 비디오 녹화\n\n```python\ncontext = browser.new_context(record_video_dir=\"videos/\")\npage = context.new_page()\n# 페이지 조작...\ncontext.close()\n```\n\n## 10. 테스트 자동화\n\nPlaywright는 pytest와 통합하여 사용할 수 있습니다:\n\n```python\n# conftest.py\nimport pytest\nfrom playwright.sync_api import sync_playwright\n\n@pytest.fixture(scope=\"session\")\ndef browser():\n    with sync_playwright() as p:\n        browser = p.chromium.launch()\n        yield browser\n        browser.close()\n\n@pytest.fixture\ndef page(browser):\n    page = browser.new_page()\n    yield page\n    page.close()\n\n# test_example.py\ndef test_example_page(page):\n    page.goto(\"https://www.example.com\")\n    assert page.title() == \"Example Domain\"\n```\n\n## 11. 고급 기능\n\n### 모바일 에뮬레이션\n\n```python\niphone_11 = playwright.devices['iPhone 11 Pro']\ncontext = browser.new_context(**iphone_11)\n```\n\n### 지리적 위치 설정\n\n```python\ncontext = browser.new_context(\n    geolocation={\"latitude\": 41.890221, \"longitude\": 12.492348},\n    permissions=[\"geolocation\"]\n)\n```\n\n### 인증 처리\n\n```python\ncontext = browser.new_context(\n    http_credentials={\"username\": \"user\", \"password\": \"pass\"}\n)\n```\n\n## 12. 문제 해결 및 팁\n\n- 요소를 찾지 못할 때는 `page.wait_for_selector()`를 사용하여 요소가 나타날 때까지 기다립니다.\n- 비동기 작업을 처리할 때는 `page.wait_for_load_state(\"networkidle\")`를 사용합니다.\n- 디버깅을 위해 `page.pause()`를 사용하여 스크립트 실행을 일시 중지할 수 있습니다.\n- 성능 최적화를 위해 불필요한 리소스 로딩을 차단합니다:\n\n```python\npage.route(\"**/*.{png,jpg,jpeg}\", lambda route: route.abort())\n```\n\n이 가이드는 Playwright Python의 주요 기능과 사용법을 다루고 있습니다. 더 자세한 정보나 특정 사용 사례에 대해서는 [공식 Playwright Python 문서](https://playwright.dev/python/)를 참조하세요.\n"},{"excerpt":"Playwright 경량 설치 가이드 개요 Playwright는 웹 애플리케이션 자동화를 위한 강력한 도구지만, 최소한의 구성 요소로만 설치해야 하는 경우가 있습니다. 이 가이드는 필수적인 구성 요소만 설치하여 Playwright를 가볍게 구성하는 방법을 설명합니다. 최소 설치 단계 1. pip 업그레이드 생략 (선택 사항) 이미 호환 가능한 버전의 pi…","fields":{"slug":"/Lightweight_Playwright_Installation/"},"frontmatter":{"date":"December 09, 2024","title":"Playwright 경량 설치 가이드","tags":["Playwright","설치","최적화"]},"rawMarkdownBody":"\n# Playwright 경량 설치 가이드\n\n## 개요\n\nPlaywright는 웹 애플리케이션 자동화를 위한 강력한 도구지만, 최소한의 구성 요소로만 설치해야 하는 경우가 있습니다. 이 가이드는 필수적인 구성 요소만 설치하여 Playwright를 가볍게 구성하는 방법을 설명합니다.\n\n---\n\n## 최소 설치 단계\n\n### 1. pip 업그레이드 생략 (선택 사항)\n\n이미 호환 가능한 버전의 pip이 설치되어 있다면 업그레이드를 생략할 수 있습니다. 그렇지 않다면 아래 명령어로 업그레이드하세요:\n\n```bash\npip install --upgrade pip\n```\n\n---\n\n### 2. Playwright 핵심 패키지 설치\n\n브라우저 없이 Playwright 핵심 패키지만 설치합니다:\n\n```bash\npip install playwright\n```\n\n---\n\n### 3. 특정 브라우저만 설치 (예: Chromium)\n\n추가적인 의존성을 설치하지 않고 특정 브라우저만 설치하려면:\n\n```bash\nplaywright install chromium\n```\n\n- `--with-deps`를 생략하면 불필요한 시스템 라이브러리 설치를 방지할 수 있습니다.\n- 이 방법은 필요한 브라우저만 설치하므로 설치가 간단하고 경량화됩니다.\n\n---\n\n### 4. 브라우저 설치 생략 (원격 브라우저 사용)\n\n브라우저 설치를 완전히 생략하고, Playwright를 원격 브라우저(예: Docker 컨테이너에서 실행 중인 Headless Chrome)와 연결하여 사용할 수 있습니다. Python 예제:\n\n```python\nfrom playwright.sync_api import sync_playwright\n\nwith sync_playwright() as p:\n    browser = p.chromium.connect_over_cdp(\"ws://<remote-browser-address>\")\n    page = browser.new_page()\n    page.goto(\"https://example.com\")\n    print(page.title())\n    browser.close()\n```\n\n이 방식에서는:\n\n- 로컬 브라우저가 필요 없습니다.\n- 원격 환경(예: Docker 컨테이너 또는 서버)에서 브라우저를 실행합니다.\n\n---\n\n## 명령어 요약\n\n| 명령어                        | 설명                                       |\n| ----------------------------- | ------------------------------------------ |\n| `pip install playwright`      | Playwright 핵심 패키지 설치.               |\n| `playwright install chromium` | Chromium 브라우저만 설치.                  |\n| `pip install --upgrade pip`   | 선택 사항: pip을 최신 버전으로 업그레이드. |\n\n---\n\n## 사용 사례\n\n- **로컬 테스트**: Chromium 브라우저만 설치하여 테스트 환경 구성.\n- **원격 테스트**: 브라우저 설치를 생략하고 원격 브라우저 연결.\n- **CI/CD 환경**: 설치를 최소화하여 리소스 절약 및 설정 시간 단축.\n\n---\n"},{"excerpt":"Robyn 개발 가이드 개요 Robyn은 Python 기반의 고성능 웹 프레임워크로, Rust로 작성된 웹 서버 엔진을 사용하여 성능과 효율성을 극대화합니다. 경량 설치와 비동기 지원, 그리고 WebSocket 기능을 통해 실시간 애플리케이션 개발에 적합합니다. 주요 특징 Rust 기반 성능: Rust로 작성된 엔진 덕분에 뛰어난 성능 제공. Python…","fields":{"slug":"/Robyn_development/"},"frontmatter":{"date":"December 09, 2024","title":"Robyn 개발 가이드","tags":["Robyn","Python","Rust","Web Development"]},"rawMarkdownBody":"\n# Robyn 개발 가이드\n\n## 개요\n\nRobyn은 Python 기반의 **고성능 웹 프레임워크**로, Rust로 작성된 웹 서버 엔진을 사용하여 성능과 효율성을 극대화합니다. 경량 설치와 비동기 지원, 그리고 WebSocket 기능을 통해 실시간 애플리케이션 개발에 적합합니다.\n\n---\n\n## 주요 특징\n\n1. **Rust 기반 성능**:\n\n   - Rust로 작성된 엔진 덕분에 뛰어난 성능 제공.\n   - Python의 편의성과 Rust의 성능 결합.\n\n2. **비동기 I/O**:\n\n   - 비동기 함수 지원을 통해 높은 동시성을 처리.\n\n3. **WebSocket 지원**:\n\n   - 실시간 데이터 전송이 필요한 애플리케이션에 적합.\n\n4. **경량 설치**:\n\n   - 설치가 간단하고 최소한의 종속성만 필요.\n\n5. **간단한 API**:\n   - Pythonic한 인터페이스로 빠르게 개발 가능.\n\n---\n\n## 설치 및 첫 번째 애플리케이션 실행\n\n### 1. Robyn 설치\n\nRobyn은 Python 패키지로 제공됩니다. 다음 명령어로 설치합니다:\n\n```bash\npip install robyn\n```\n\n---\n\n### 2. 첫 번째 애플리케이션\n\n\"Hello, World!\" 서버를 실행하는 간단한 예제입니다:\n\n```python\nfrom robyn import Robyn\n\napp = Robyn(__file__)\n\n@app.get(\"/\")\nasync def home():\n    return \"Hello, World!\"\n\napp.start(port=5000)\n```\n\n- **라우트 등록**: `@app.get(\"/\")`는 GET 요청을 처리합니다.\n- **비동기 핸들러**: 모든 요청 핸들러는 `async` 함수로 작성됩니다.\n- **서버 시작**: `app.start(port=5000)`으로 서버를 실행합니다.\n\n---\n\n## 라우팅 및 HTTP 메서드\n\nRobyn은 다양한 HTTP 메서드에 대한 라우트를 지원합니다:\n\n```python\n@app.get(\"/get\")\nasync def get_handler():\n    return \"GET request\"\n\n@app.post(\"/post\")\nasync def post_handler():\n    return {\"message\": \"POST request\"}, 201\n\n@app.put(\"/put\")\nasync def put_handler():\n    return \"PUT request\"\n\n@app.delete(\"/delete\")\nasync def delete_handler():\n    return \"DELETE request\"\n```\n\n---\n\n## WebSocket 지원\n\nWebSocket을 통해 실시간 양방향 통신을 설정할 수 있습니다:\n\n```python\n@app.websocket(\"/ws\")\nasync def websocket_handler(message):\n    print(f\"Received: {message}\")\n    return \"Hello WebSocket!\"\n```\n\n---\n\n## 에러 처리\n\nRobyn은 상태 코드와 함께 응답을 반환할 수 있습니다:\n\n```python\n@app.get(\"/error\")\nasync def error_handler():\n    return {\"error\": \"Something went wrong\"}, 500\n```\n\n---\n\n## JSON 응답\n\nRobyn은 JSON 응답을 간단히 반환할 수 있습니다:\n\n```python\n@app.post(\"/json\")\nasync def json_handler():\n    return {\"message\": \"This is a JSON response\"}\n```\n\n---\n\n## 실행 및 테스트\n\n1. **서버 실행**:\n\n   ```bash\n   python app.py\n   ```\n\n2. **테스트**:\n   - 브라우저 또는 도구(예: cURL, Postman)를 사용하여 API 요청을 테스트합니다.\n\n---\n\n## 장점 및 단점\n\n### 장점\n\n- **Rust 기반 성능**: Python으로 작성된 다른 프레임워크보다 훨씬 빠름.\n- **비동기 지원**: 실시간 애플리케이션 개발에 적합.\n- **간단한 인터페이스**: Python 개발자에게 친숙.\n\n### 단점\n\n- **제한된 생태계**: Django나 Flask에 비해 확장성과 라이브러리 지원이 부족.\n- **Rust와의 혼합**: 복잡한 디버깅이 필요할 수 있음.\n- **초기 학습 곡선**: Rust와 비동기 프로그래밍 개념을 이해해야 함.\n\n---\n"},{"excerpt":"Caddy 기본 사용 목차 Caddy 소개 설치 방법 기본 명령어 Caddyfile 구조 Caddyfile 예제 DNS 및 HTTPS 설정 Caddy 관리 1. Caddy 소개 Caddy는 HTTP/HTTPS 웹 서버로, 다음과 같은 특징을 갖습니다: 자동 HTTPS 지원 간단한 구성 파일 (Caddyfile) 빠르고 효율적인 성능 플러그인 지원 2. 설…","fields":{"slug":"/Caddy_Manual/"},"frontmatter":{"date":"December 08, 2024","title":"Caddy 기본 사용","tags":["Server","Caddy"]},"rawMarkdownBody":"\n# Caddy 기본 사용\n\n### 목차\n\n1. [Caddy 소개](#1-caddy-소개)\n2. [설치 방법](#2-설치-방법)\n3. [기본 명령어](#3-기본-명령어)\n4. [Caddyfile 구조](#4-caddyfile-구조)\n5. [Caddyfile 예제](#5-caddyfile-예제)\n6. [DNS 및 HTTPS 설정](#6-dns-및-https-설정)\n7. [Caddy 관리](#7-caddy-관리)\n\n---\n\n### 1. Caddy 소개\n\n**Caddy**는 HTTP/HTTPS 웹 서버로, 다음과 같은 특징을 갖습니다:\n\n- 자동 HTTPS 지원\n- 간단한 구성 파일 (Caddyfile)\n- 빠르고 효율적인 성능\n- 플러그인 지원\n\n---\n\n### 2. 설치 방법\n\n#### **Linux**\n\n```bash\n# Caddy 설치\nsudo apt install -y debian-keyring debian-archive-keyring apt-transport-https\ncurl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo tee /etc/apt/trusted.gpg.d/caddy-stable.asc\ncurl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list\nsudo apt update\nsudo apt install caddy\n```\n\n#### **macOS**\n\n```bash\nbrew install caddy\n```\n\n#### **Windows**\n\n- Windows용 실행 파일을 [공식 다운로드 페이지](https://caddyserver.com/download)에서 다운로드합니다.\n\n---\n\n### 3. 기본 명령어\n\n#### **Caddy 실행**\n\n```bash\ncaddy run\n```\n\n#### **Caddy 종료**\n\n```bash\ncaddy stop\n```\n\n#### **Caddy 설정 파일 테스트**\n\n```bash\ncaddy validate\n```\n\n#### **Caddy 설정 재로드**\n\n```bash\nsudo systemctl reload caddy\n```\n\n#### **Caddy 서비스 상태 확인**\n\n```bash\nsudo systemctl status caddy\n```\n\n---\n\n### 4. Caddyfile 구조\n\nCaddyfile은 도메인과 관련 설정을 지정하는 텍스트 파일입니다.\n\n#### **기본 구조**\n\n```plaintext\n<도메인> {\n    <지시자> <값>\n    <지시자> {\n        <세부 설정>\n    }\n}\n```\n\n---\n\n### 5. Caddyfile 예제\n\n#### **1) 기본 설정**\n\n```caddyfile\nexample.com {\n    root * /var/www/html\n    file_server\n}\n```\n\n#### **2) HTTPS 리다이렉션**\n\n```caddyfile\nhttp://example.com {\n    redir https://example.com{uri}\n}\n```\n\n#### **3) 여러 도메인 처리**\n\n```caddyfile\nexample.com, www.example.com {\n    root * /var/www/html\n    file_server\n}\n```\n\n#### **4) 역방향 프록시**\n\n```caddyfile\nexample.com {\n    reverse_proxy 127.0.0.1:5000\n}\n```\n\n---\n\n### 6. DNS 및 HTTPS 설정\n\n#### **자동 HTTPS**\n\nCaddy는 기본적으로 Let’s Encrypt를 사용하여 HTTPS를 자동으로 설정합니다.\n\n#### **DNS 설정**\n\n- 도메인 네임을 사용하려면 DNS A/AAAA 레코드가 서버의 IP 주소를 가리키도록 설정해야 합니다.\n\n---\n\n### 7. Caddy 관리\n\n#### **서비스 시작**\n\n```bash\nsudo systemctl start caddy\n```\n\n#### **서비스 중지**\n\n```bash\nsudo systemctl stop caddy\n```\n\n#### **서비스 재시작**\n\n```bash\nsudo systemctl restart caddy\n```\n\n#### **로그 확인**\n\n```bash\njournalctl -u caddy --no-pager\n```\n\n---\n\n### 참고 자료\n\n- [Caddy 공식 문서](https://caddyserver.com/docs/)\n- [Caddy 다운로드](https://caddyserver.com/download)\n\n---\n"},{"excerpt":"Caddy Docker Compose 사용 목차 소개 필요한 파일 준비 docker-compose.yml 작성 Caddyfile 작성 Docker Compose 명령어 HTTPS 설정 및 확인 참고 자료 1. 소개 Caddy는 Docker Compose를 통해 간편하게 실행할 수 있는 HTTP/HTTPS 웹 서버입니다. Docker를 활용하면 Caddy의…","fields":{"slug":"/Caddy_Docker_Compose_Manual/"},"frontmatter":{"date":"December 08, 2024","title":"Caddy Docker Compose 사용","tags":["Server","Caddy","Docker"]},"rawMarkdownBody":"\n# Caddy Docker Compose 사용\n\n### 목차\n\n1. [소개](#1-소개)\n2. [필요한 파일 준비](#2-필요한-파일-준비)\n3. [docker-compose.yml 작성](#3-docker-composeyml-작성)\n4. [Caddyfile 작성](#4-caddyfile-작성)\n5. [Docker Compose 명령어](#5-docker-compose-명령어)\n6. [HTTPS 설정 및 확인](#6-https-설정-및-확인)\n7. [참고 자료](#7-참고-자료)\n\n---\n\n### 1. 소개\n\n**Caddy**는 Docker Compose를 통해 간편하게 실행할 수 있는 HTTP/HTTPS 웹 서버입니다. Docker를 활용하면 Caddy의 실행과 관리를 더욱 쉽게 자동화할 수 있습니다.\n\n---\n\n### 2. 필요한 파일 준비\n\nCaddy를 Docker Compose로 실행하려면 아래 파일들이 필요합니다:\n\n1. **docker-compose.yml**\n2. **Caddyfile**\n\n---\n\n### 3. docker-compose.yml 작성\n\n`docker-compose.yml` 파일은 Caddy 컨테이너의 실행 환경을 정의합니다.\n\n```yaml\nversion: '3.8'\n\nservices:\n  caddy:\n    image: caddy:latest\n    container_name: caddy_server\n    ports:\n      - '80:80'\n      - '443:443'\n    volumes:\n      - ./Caddyfile:/etc/caddy/Caddyfile\n      - ./site:/usr/share/caddy\n      - caddy_data:/data\n      - caddy_config:/config\n    restart: unless-stopped\n\nvolumes:\n  caddy_data:\n  caddy_config:\n```\n\n---\n\n### 4. Caddyfile 작성\n\nCaddyfile은 Caddy 서버의 동작을 정의하는 설정 파일입니다.\n\n#### **1) 기본 설정 예제**\n\n```caddyfile\nexample.com {\n    root * /usr/share/caddy\n    file_server\n}\n```\n\n#### **2) HTTPS 리다이렉션**\n\n```caddyfile\nhttp://example.com {\n    redir https://example.com{uri}\n}\n```\n\n#### **3) 역방향 프록시**\n\n```caddyfile\nexample.com {\n    reverse_proxy 127.0.0.1:5000\n}\n```\n\n---\n\n### 5. Docker Compose 명령어\n\nDocker Compose를 이용해 Caddy 서버를 실행 및 관리합니다.\n\n#### **1) 컨테이너 시작**\n\n```bash\ndocker-compose up -d\n```\n\n#### **2) 컨테이너 종료**\n\n```bash\ndocker-compose down\n```\n\n#### **3) 컨테이너 로그 확인**\n\n```bash\ndocker-compose logs -f caddy\n```\n\n#### **4) 컨테이너 상태 확인**\n\n```bash\ndocker ps\n```\n\n#### **5) 설정 변경 후 재시작**\n\n```bash\ndocker-compose up -d --force-recreate\n```\n\n---\n\n### 6. HTTPS 설정 및 확인\n\nCaddy는 Let’s Encrypt를 통해 자동으로 HTTPS 인증서를 발급합니다.\n\n1. **DNS 설정**\n\n   - 도메인 네임의 DNS A/AAAA 레코드를 Caddy 서버의 IP 주소로 설정합니다.\n\n2. **HTTPS 확인**\n   - 브라우저에서 도메인을 입력하고 HTTPS 연결을 확인합니다.\n\n---\n\n### 7. 참고 자료\n\n- [Caddy 공식 문서](https://caddyserver.com/docs/)\n- [Caddy Docker Hub](https://hub.docker.com/_/caddy)\n- [Docker Compose 공식 문서](https://docs.docker.com/compose/)\n"},{"excerpt":"MongoDB 기본 사용 MongoDB는 가장 인기 있는 NoSQL 데이터베이스 중 하나입니다. 이 글에서는 MongoDB의 기본적인 개념과 사용법에 대해 알아보겠습니다. MongoDB란? MongoDB는 문서 지향(Document-Oriented) 데이터베이스입니다. JSON과 유사한 형태의 BSON(Binary JSON) 형식으로 데이터를 저장하며, …","fields":{"slug":"/mongodb-basics/"},"frontmatter":{"date":"December 08, 2024","title":"MongoDB 기본 사용","tags":["Database","MongoDB","NoSQL"]},"rawMarkdownBody":"\n# MongoDB 기본 사용\n\nMongoDB는 가장 인기 있는 NoSQL 데이터베이스 중 하나입니다. 이 글에서는 MongoDB의 기본적인 개념과 사용법에 대해 알아보겠습니다.\n\n## MongoDB란?\n\nMongoDB는 문서 지향(Document-Oriented) 데이터베이스입니다. JSON과 유사한 형태의 BSON(Binary JSON) 형식으로 데이터를 저장하며, 스키마가 유연하고 확장성이 뛰어난 것이 특징입니다.\n\n### MongoDB의 주요 특징\n\n- 스키마리스(Schemaless) 구조\n- 수평적 확장 가능(Horizontal Scalability)\n- 높은 가용성(High Availability)\n- 풍부한 쿼리 기능\n\n## 기본 구조\n\nMongoDB의 기본 구조는 다음과 같습니다:\n\n- 데이터베이스 (Database)\n  - 컬렉션 (Collection)\n    - 문서 (Document)\n\n이는 관계형 데이터베이스의 구조와 비교하면 다음과 같습니다:\n\n| RDBMS    | MongoDB    |\n| -------- | ---------- |\n| Database | Database   |\n| Table    | Collection |\n| Row      | Document   |\n| Column   | Field      |\n\n## 기본 명령어\n\n### 데이터베이스 관련\n\n```javascript\n// 데이터베이스 목록 조회\nshow dbs\n\n// 데이터베이스 선택/생성\nuse mydb\n\n// 현재 데이터베이스 확인\ndb\n```\n\n### 컬렉션 관련\n\n```javascript\n// 컬렉션 생성\ndb.createCollection(\"users\")\n\n// 컬렉션 목록 조회\nshow collections\n\n// 컬렉션 삭제\ndb.users.drop()\n```\n\n### CRUD 작업\n\n#### Create (생성)\n\n```javascript\n// 단일 문서 삽입\ndb.users.insertOne({\n  name: '홍길동',\n  age: 30,\n  email: 'hong@example.com',\n});\n\n// 다수 문서 삽입\ndb.users.insertMany([\n  {\n    name: '김철수',\n    age: 25,\n    email: 'kim@example.com',\n  },\n  {\n    name: '이영희',\n    age: 28,\n    email: 'lee@example.com',\n  },\n]);\n```\n\n#### Read (조회)\n\n```javascript\n// 모든 문서 조회\ndb.users.find();\n\n// 조건부 조회\ndb.users.find({ age: { $gt: 25 } });\n\n// 특정 필드만 조회\ndb.users.find({}, { name: 1, email: 1 });\n\n// 정렬\ndb.users.find().sort({ age: -1 });\n\n// 제한\ndb.users.find().limit(5);\n```\n\n#### Update (수정)\n\n```javascript\n// 단일 문서 수정\ndb.users.updateOne({ name: '홍길동' }, { $set: { age: 31 } });\n\n// 다수 문서 수정\ndb.users.updateMany({ age: { $lt: 30 } }, { $inc: { age: 1 } });\n```\n\n#### Delete (삭제)\n\n```javascript\n// 단일 문서 삭제\ndb.users.deleteOne({ name: '홍길동' });\n\n// 다수 문서 삭제\ndb.users.deleteMany({ age: { $lt: 25 } });\n```\n\n## 쿼리 연산자\n\nMongoDB는 다양한 쿼리 연산자를 제공합니다.\n\n### 비교 연산자\n\n- `$eq`: 같음\n- `$ne`: 같지 않음\n- `$gt`: 초과\n- `$gte`: 이상\n- `$lt`: 미만\n- `$lte`: 이하\n- `$in`: 배열 내 존재\n- `$nin`: 배열 내 존재하지 않음\n\n```javascript\n// 나이가 25세 초과인 사용자 조회\ndb.users.find({ age: { $gt: 25 } });\n\n// 나이가 25세 이상 30세 이하인 사용자 조회\ndb.users.find({ age: { $gte: 25, $lte: 30 } });\n```\n\n### 논리 연산자\n\n- `$and`: AND 조건\n- `$or`: OR 조건\n- `$not`: NOT 조건\n- `$nor`: NOR 조건\n\n```javascript\n// AND 조건\ndb.users.find({\n  $and: [{ age: { $gt: 25 } }, { name: '홍길동' }],\n});\n\n// OR 조건\ndb.users.find({\n  $or: [{ age: { $lt: 25 } }, { age: { $gt: 30 } }],\n});\n```\n\n## 인덱싱\n\n인덱스를 사용하면 쿼리 성능을 향상시킬 수 있습니다.\n\n```javascript\n// 단일 필드 인덱스 생성\ndb.users.createIndex({ email: 1 });\n\n// 복합 인덱스 생성\ndb.users.createIndex({ name: 1, age: -1 });\n\n// 인덱스 확인\ndb.users.getIndexes();\n\n// 인덱스 삭제\ndb.users.dropIndex({ email: 1 });\n```\n\n## 실제 사용 예시\n\n### 사용자 프로필 관리\n\n```javascript\n// 사용자 프로필 컬렉션\ndb.profiles.insertOne({\n  userId: 'user123',\n  name: '홍길동',\n  age: 30,\n  address: {\n    city: '서울',\n    street: '강남대로',\n  },\n  hobbies: ['독서', '등산'],\n  createdAt: new Date(),\n});\n\n// 프로필 조회\ndb.profiles.find({\n  'address.city': '서울',\n  hobbies: '독서',\n});\n```\n\n### 게시물 관리\n\n```javascript\n// 게시물 생성\ndb.posts.insertOne({\n  title: '첫 번째 게시물',\n  content: '내용입니다...',\n  author: 'user123',\n  tags: ['mongodb', 'database'],\n  comments: [\n    {\n      user: 'user456',\n      text: '좋은 글이네요',\n      createdAt: new Date(),\n    },\n  ],\n  createdAt: new Date(),\n});\n\n// 특정 태그를 가진 게시물 조회\ndb.posts.find({ tags: 'mongodb' });\n```\n\n## 마치며\n\n이상으로 MongoDB의 기본적인 사용법에 대해 알아보았습니다. MongoDB는 유연한 스키마와 풍부한 쿼리 기능을 제공하여 현대적인 애플리케이션 개발에 매우 적합합니다. 다음 글에서는 MongoDB의 고급 기능들에 대해 더 자세히 알아보도록 하겠습니다.\n"},{"excerpt":"Lazydocker 기본 사용 Lazydocker는 Docker와 Docker-compose를 위한 간단한 터미널 UI입니다. 아래는 효과적으로 사용하는 방법에 대한 가이드입니다. 설치 Lazydocker를 사용하기 전에 설치되어 있는지 확인하십시오. 설치되지 않은 경우 설치 지침을 따르십시오. Lazydocker 실행 Lazydocker 인터페이스를 시…","fields":{"slug":"/Lazydocker_Basic_Manual/"},"frontmatter":{"date":"December 08, 2024","title":"Lazydocker 기본 사용","tags":["Docker","Lazydocker"]},"rawMarkdownBody":"\n# Lazydocker 기본 사용\n\nLazydocker는 Docker와 Docker-compose를 위한 간단한 터미널 UI입니다. 아래는 효과적으로 사용하는 방법에 대한 가이드입니다.\n\n---\n\n## **설치**\n\nLazydocker를 사용하기 전에 설치되어 있는지 확인하십시오. 설치되지 않은 경우 [설치 지침](https://github.com/jesseduffield/lazydocker)을 따르십시오.\n\n---\n\n## **Lazydocker 실행**\n\nLazydocker 인터페이스를 시작하려면 다음 명령을 실행하십시오:\n\n```bash\nlazydocker\n```\n\n---\n\n## **탐색**\n\n인터페이스는 여러 섹션으로 나뉩니다. 다음 키를 사용하여 탐색하십시오:\n\n- **화살표 키**: 컨테이너, 이미지, 볼륨 및 서비스를 탐색합니다.\n- **Enter**: 강조 표시된 항목을 선택합니다.\n- **Esc**: 현재 패널 또는 메뉴를 종료합니다.\n- **Tab**: 패널 간 포커스를 전환합니다.\n\n---\n\n## **키 명령**\n\n아래는 Lazydocker에서 가장 자주 사용되는 명령입니다:\n\n| 키  | 동작                              |\n| --- | --------------------------------- |\n| `q` | Lazydocker 종료                   |\n| `l` | 선택한 컨테이너의 로그 보기       |\n| `e` | 컨테이너/서비스 환경 보기         |\n| `r` | 선택한 컨테이너 재시작            |\n| `s` | 선택한 컨테이너 중지              |\n| `u` | 선택한 컨테이너 시작 (Up)         |\n| `d` | 선택한 컨테이너/이미지 제거       |\n| `b` | 서비스 재빌드 (docker-compose)    |\n| `p` | 선택한 컨테이너 일시 중지         |\n| `x` | 사용하지 않는 리소스 제거 (prune) |\n\n---\n\n## **기능**\n\n### 1. **컨테이너 관리**\n\n- 실행 중인 컨테이너, 상태 및 로그 보기.\n- 단축키로 컨테이너 재시작, 중지 또는 제거.\n\n### 2. **이미지 관리**\n\n- 사용 가능한 Docker 이미지 보기.\n- 사용하지 않거나 불필요한 이미지 제거.\n\n### 3. **볼륨 관리**\n\n- Docker 볼륨 검사 및 사용하지 않는 볼륨 정리.\n\n### 4. **서비스 관리**\n\n- `docker-compose.yml`에 정의된 서비스 모니터링.\n- 서비스를 시작하거나 중지하고 재빌드.\n\n---\n\n## **효율적인 사용을 위한 팁**\n\n1. **사용자 정의 구성**:\n   Lazydocker는 구성 파일을 사용자 정의할 수 있습니다. 고급 설정을 위해 `~/.config/lazydocker/config.yml`을 편집하십시오.\n\n2. **리소스 정리**:\n   사용하지 않는 이미지, 볼륨 및 네트워크를 정기적으로 정리하여 디스크 공간을 확보하십시오:\n\n   - 인터페이스에서 `x`를 사용하여 리소스를 정리하십시오.\n\n3. **로그 보기**:\n   로그 보기(`l`)는 컨테이너의 출력을 실시간으로 제공하여 디버깅을 쉽게 만듭니다.\n\n---\n\n## **Lazydocker 종료**\n\n인터페이스를 종료하려면 `q` 또는 `Ctrl+C`를 누르십시오.\n\n---\n\n## **참고 자료**\n\n- [공식 Lazydocker GitHub 저장소](https://github.com/jesseduffield/lazydocker)\n\n---\n\n**Lazydocker로 Docker 컨테이너를 손쉽게 관리하세요!**\n"},{"excerpt":"macOS 앱 실행 문제 해결: 인증되지 않은 앱 허용하기 macOS에서는 보안상의 이유로 인증되지 않은 앱(특히 App Store 외부에서 다운로드한 앱)의 실행을 제한합니다. 하지만 개발자나 특정 앱 사용자에게는 이러한 제한이 번거로울 수 있습니다. 아래 방법을 통해 인증되지 않은 앱을 실행할 수 있도록 설정하고, 다시 원래 상태로 복구하는 방법을 소…","fields":{"slug":"/apple  프로그램 깨져서 실행 안될때/"},"frontmatter":{"date":"December 07, 2024","title":"apple  프로그램 깨져서 실행 안될때","tags":["apple"]},"rawMarkdownBody":"\n# macOS 앱 실행 문제 해결: 인증되지 않은 앱 허용하기\n\nmacOS에서는 보안상의 이유로 인증되지 않은 앱(특히 App Store 외부에서 다운로드한 앱)의 실행을 제한합니다. 하지만 개발자나 특정 앱 사용자에게는 이러한 제한이 번거로울 수 있습니다. 아래 방법을 통해 인증되지 않은 앱을 실행할 수 있도록 설정하고, 다시 원래 상태로 복구하는 방법을 소개합니다.\n\n---\n\n## **명령어 설명**\n\n아래 명령어는 macOS의 **Gatekeeper**와 관련된 보안 설정을 조정하여, 인증되지 않은 앱을 실행할 수 있도록 합니다.\n\n```bash\n# 1. Gatekeeper 비활성화\nsudo spctl --master-disable\n\n# 2. 앱의 격리 속성을 제거 (예: Sublime Text)\nsudo xattr -r -d com.apple.quarantine /Applications/Sublime\\ Text.app\n\n# 3. 다른 앱도 동일하게 처리\nsudo xattr -d com.apple.quarantine /Applications/xxxx.app\n\n# 4. Gatekeeper 다시 활성화\nsudo spctl --master-enable\n\n```\n"},{"excerpt":"Python 가상환경 활성화 시 발생하는 PowerShell 보안 정책 오류 해결하기 문제 상황 새로운 노트북에서 Python 가상환경을 설정하는 과정에서 흔히 마주치는 문제가 있습니다. PowerShell에서 가상환경을 활성화하려고 할 때 다음과 같은 보안 관련 오류 메시지를 만나게 되죠. 원인 분석 이러한 오류가 발생하는 이유는 Windows Powe…","fields":{"slug":"/윈도우에서 Python 가상환경 활성화/"},"frontmatter":{"date":"December 07, 2024","title":"윈도우에서 Python 가상환경 활성화","tags":["Virtual Environment","Python"]},"rawMarkdownBody":"\n# Python 가상환경 활성화 시 발생하는 PowerShell 보안 정책 오류 해결하기\n\n## 문제 상황\n\n새로운 노트북에서 Python 가상환경을 설정하는 과정에서 흔히 마주치는 문제가 있습니다. PowerShell에서 가상환경을 활성화하려고 할 때 다음과 같은 보안 관련 오류 메시지를 만나게 되죠.\n\n```powershell\n.\\activate.ps1 : 이 시스템에서 스크립트를 실행할 수 없으므로 C:\\Users\\20170218\\Desktop\\temp\\naver_stock\\venv\\Scripts\\activate.ps1 파일을 로드할 수 없습니다.\n자세한 내용은 about_Execution_Policies(https://go.microsoft.com/fwlink/?LinkID=135170)를 참조하십시오.\n위치 줄:1 문자:1\n+ .\\activate.ps1\n    + CategoryInfo          : 보안 오류: (:) [], PSSecurityException\n    + FullyQualifiedErrorId : UnauthorizedAccess\n```\n\n## 원인 분석\n\n이러한 오류가 발생하는 이유는 Windows PowerShell의 기본 보안 정책 때문입니다. PowerShell은 기본적으로 스크립트 실행을 제한하는 정책을 가지고 있어, 악성 스크립트로부터 시스템을 보호합니다. 하지만 이러한 보안 정책이 때로는 우리가 필요한 정상적인 스크립트의 실행도 막게 되죠.\n\n## 해결 방법\n\n다행히도 이 문제는 간단한 단계를 통해 해결할 수 있습니다.\n\n### 1단계: PowerShell 관리자 모드로 실행\n\n- Windows 시작 메뉴에서 PowerShell을 검색\n- 마우스 우클릭 후 \"관리자 권한으로 실행\" 선택\n\n### 2단계: 실행 정책 변경\n\n관리자 모드의 PowerShell에서 다음 명령어를 실행합니다:\n\n```powershell\nSet-ExecutionPolicy Unrestricted\n```\n\n이 명령어는 PowerShell의 스크립트 실행 정책을 'Unrestricted'로 변경하여, 신뢰할 수 있는 스크립트의 실행을 허용합니다.\n\n## 주의사항\n\n보안 정책을 변경하는 것은 시스템의 보안에 영향을 미칠 수 있습니다. 따라서 다음 사항들을 유의해야 합니다:\n\n1. 신뢰할 수 있는 소스의 스크립트만 실행하기\n2. 필요한 작업이 끝난 후에는 보안 정책을 다시 제한적으로 설정하는 것을 고려하기\n3. 개발 환경과 운영 환경을 분리하여 관리하기\n\n## 마치며\n\n이러한 보안 정책 관련 오류는 개발 환경을 새로 설정할 때 자주 마주치는 문제 중 하나입니다. 위의 해결 방법을 통해 Python 가상환경을 원활하게 사용할 수 있게 되었지만, 항상 보안과 편의성 사이의 균형을 고려하는 것이 중요합니다.\n\n더 자세한 내용이나 다양한 실행 정책 옵션에 대해 알고 싶다면, [Microsoft의 공식 문서](https://go.microsoft.com/fwlink/?LinkID=135170)를 참조하시기 바랍니다.\n\n---\n\n_이 글은 Python 개발 환경 설정 시리즈의 일부입니다._\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}